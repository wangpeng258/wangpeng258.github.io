<!DOCTYPE html>
<html lang="en">

    <head>
        <meta name="viewport"
            content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
        <link href="https://cdn.bootcdn.net/ajax/libs/vant/2.12.25/index.min.css" rel="stylesheet">
        <script src="https://dcdn.it120.cc/2022/12/09/89f2df97-9b7c-4650-9cce-7d885642564b.js"></script>
        <script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.11/vue.min.js"></script>
        <script src="https://cdn.bootcdn.net/ajax/libs/vant/2.12.25/vant.min.js"></script>
        <script src="https://cdn.bootcdn.net/ajax/libs/tensorflow/3.19.0/tf.min.js"></script>
        <script src="https://unpkg.com/@mediapipe/face_mesh"></script>
        <script src="https://unpkg.com/@tensorflow-models/face-landmarks-detection"></script>
        <script src="https://unpkg.com/kalidokit/dist/kalidokit.umd.js"></script>
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <style>
            * {
                padding: 0;
                margin: 0;
            }

            html,
            body,
            #app {
                width: 100%;
                height: 100%;
                overflow: hidden;
            }

            [v-cloak] {
                opacity: 0 !important;
            }

            .helpdialog .van-dialog__message {
                line-height: 1;
                white-space: unset;
            }

            .prompt-text {
                font-size: 18px;
                padding: 15px;
                color: #000;
            }

            .prompt-text>h5 {
                opacity: 0.9;
                padding-bottom: 1em;
            }

            .prompt-text>ol {
                text-align: left;
                opacity: 0.8;
                list-style: revert;
                font-size: 13px;
                line-height: 1.7;
                padding-left: 1em;
            }

            .faceMesh {
                width: 100%;
                height: 100%;
                background-color: #000;
                overflow: hidden;
            }

            .faceMesh .meshPopup {
                overflow: hidden;
            }

            .faceMesh .meshPopup .meshPopup-title {
                font-size: 15px;
                padding: 0;
                margin: 0;
                display: flex;
                justify-content: center;
                align-items: center;
                height: 55px;
            }

            .faceMesh .meshPopup .meshList {
                display: flex;
                flex-wrap: wrap;
                align-items: center;
                justify-content: center;
            }

            .faceMesh .meshPopup .meshList .meshList-item {
                width: 100px;
                height: 100px;
                margin: 10px;
                overflow: hidden;
                position: relative;
                border: 3px solid #e8e8e8;
                transition: 0.35s;
                border-radius: 5px;
            }

            .faceMesh .meshPopup .meshList .meshList-item.meshAction {
                border: 3px solid #1989fa;
            }

            .faceMesh .meshPopup .meshList .meshList-item .van-image,
            .faceMesh .meshPopup .meshList .meshList-item .van-image>img {
                display: block;
                width: 100%;
                height: 100%;
            }

            .faceMesh .meshPopup .meshList .meshList-item .meshName {
                position: absolute;
                left: 50%;
                bottom: 0;
                transform: translateX(-50%);
                width: 100%;
                text-align: center;
                background-color: rgba(0, 0, 0, 0.5);
                color: #fff;
                font-size: 12px;
                padding: 4px 0;
            }

            .faceMesh .meshPopup .meshList .meshList-item .van-uploader {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                z-index: 10;
                opacity: 0;
            }

            .faceMesh .meshPopup .meshList .meshList-item .uploader-text {
                user-select: none;
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                z-index: 9;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            .faceMesh .meshPopup .meshList .meshList-item .uploader-text>div {
                text-align: center;
            }

            .faceMesh .meshPopup .meshList .meshList-item .uploader-text .van-icon {
                color: #ababab;
                font-size: 24px;
            }

            .faceMesh .meshPopup .meshList .meshList-item .uploader-text p {
                color: #666;
                margin: 3px;
                font-size: 12px;
            }

            .faceMesh .scrollbar-y {
                overflow: hidden auto;
                -webkit-overflow-scrolling: touch;
                position: relative;
            }

            .faceMesh .canvas-wrapper {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                user-select: none;
                max-width: 600px;
                margin: 0 auto;
                width: 100%;
                height: 100%;
                overflow: hidden;
            }

            .faceMesh .canvas-wrapper>video {
                background: #000;
                display: block;
                width: 100%;
                height: auto;
                position: absolute;
                top: 50%;
                left: 50%;
                z-index: 1;
            }

            .faceMesh .canvas-wrapper>canvas {
                display: block;
                width: 100%;
                position: absolute;
                top: 50%;
                left: 50%;
                z-index: 2;
                transform: translate(-50%, -50%) scale(1, 1);
            }

            .faceMesh .helpCollapse {
                margin: 15px;
            }

            .faceMesh .btn-group {
                position: fixed;
                bottom: 5vh;
                left: 50%;
                transform: translateX(-50%);
                z-index: 10;
                display: flex;
                justify-content: center;
                align-items: center;
                width: 320px;
            }

            .faceMesh .btn-group>button {
                border-radius: 0;
                flex: 1;
                background-color: rgba(255, 255, 255, 0.95);
            }

            .faceMesh .btn-group>button:first-child {
                border-radius: 5px 0 0 5px;
            }

            .faceMesh .btn-group>button:last-child {
                border-radius: 0 5px 5px 0;
            }

            .faceMesh .btn-group .flipHorizontalBut .van-button__icon {
                transform: rotate(90deg);
            }
        </style>
    </head>

    <body>
        <div id="app" v-cloak>
            <div class="faceMesh">
                <div class="canvas-wrapper" ref="wrapper">
                    <video ref="video"
                        :style="{ 'transform': flipHorizontal ? 'translate(-50%,-50%) scale(-1, 1)' : 'translate(-50%,-50%) scale(1, 1)' }"
                        webkit-playsinline="true" playsinline="true" preload autoplay loop muted></video>
                    <canvas ref="canvas"
                        :style="{ 'transform': flipHorizontal ? 'translate(-50%,-50%) scale(-1, 1)' : 'translate(-50%,-50%) scale(1, 1)' }"
                        :width="canvasWidth" :height="canvasHeight"></canvas>
                </div>
                <!-- 切换摄像头 -->
                <van-action-sheet v-model="actionShow" :actions="deviceList" description="请选择设备" @select="actionSelect"
                    cancel-text="取消" close-on-click-action>
                </van-action-sheet>
                <!-- 切换摄像头 -->

                <div class="btn-group">
                    <van-button type="default" native-type="button" size="small" icon="photograph"
                        @click="actionShow = true">切换摄像头
                    </van-button>
                    <van-button type="default" native-type="button" size="small" icon="smile" @click="meshPopup = true">
                        选择特效
                    </van-button>
                    <van-button type="default" native-type="button" size="small"
                        :icon="flipHorizontal?'ascending':'descending'" @click="triggerToggleFlipHorizontal"
                        class="flipHorizontalBut">切换镜像</van-button>
                </div>

                <!-- 选择特效 -->
                <van-popup class="meshPopup" v-model="meshPopup" position="bottom"
                    :style="{ height: '80%',width:'100%' }" round closeable>
                    <h2 class="meshPopup-title van-hairline--bottom">选择特效</h2>
                    <van-tabs type="card" v-model="tabsActive" @change="tabsChange">
                        <van-tab name="stickers" title="贴纸"></van-tab>
                        <van-tab name="3Dmodel" title="3D模型"></van-tab>
                    </van-tabs>
                    <div class="scrollbar-y" style="height: calc(100% - 55px - 30px);background-color: #f7f8fa;">
                        <div class="meshList">
                            <div class="meshList-item" v-for="(item,index) in meshList" :key="index"
                                :class="{meshAction:meshIndex===index}"
                                @click="meshIndex!=index && changeMesh(meshIndex=index)">
                                <van-image :src="item.src" fit="cover"></van-image>
                                <div class="meshName van-ellipsis" v-if="item.name" v-text="item.name"></div>
                            </div>
                            <div class="meshList-item" v-if="tabsActive==='stickers'">
                                <van-uploader :before-read="uploaderImage" preview-size="100px" accept="image/*">
                                </van-uploader>
                                <div class="uploader-text">
                                    <div>
                                        <van-icon name="photograph" />
                                        <p>上传图片</p>
                                    </div>
                                </div>
                            </div>
                            <div class="meshList-item" v-if="tabsActive==='3Dmodel'">
                                <van-uploader :before-read="uploaderGlb" preview-size="100px" accept="*"></van-uploader>
                                <div class="uploader-text">
                                    <div>
                                        <van-icon name="photograph" />
                                        <p>上传glb模型</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="helpCollapse">
                            <van-collapse v-model="helpTextModel" v-if="tabsActive==='stickers'">
                                <van-collapse-item title="如何制作贴纸？" name="0">
                                    首先<a href="https://dcdn.it120.cc/2022/12/06/2b63b0b4-a4b8-481d-97ab-60c2a09d740b.jpg"
                                        target="_blank"
                                        rel="noopener noreferrer">下载面部网格</a>，导入PS或其他制图工具，将面部网格图片设置为最底层，然后在上面绘制图案，然后导出PNG。
                                </van-collapse-item>
                            </van-collapse>
                            <van-collapse v-model="helpTextModel" v-if="tabsActive==='3Dmodel'">
                                <van-collapse-item title="如何制作3D模型？" name="0">
                                    关于3D模型和形态动画如何制作，这需要一定的3D绘图基础，您也可以到<a href="https://sketchfab.com/3d-models"
                                        target="_blank" rel="noopener noreferrer">sketchfab</a>中下载制作好的模型。
                                </van-collapse-item>
                            </van-collapse>
                        </div>


                    </div>
                </van-popup>
                <!-- 选择特效 -->
            </div>
        </div>
        <script>
            const TRIANGULATION = [127, 34, 139, 11, 0, 37, 232, 231, 120, 72, 37, 39, 128, 121, 47, 232, 121, 128, 104, 69, 67, 175, 171, 148, 157, 154, 155, 118, 50, 101, 73, 39, 40, 9, 151, 108, 48, 115, 131, 194, 204, 211, 74, 40, 185, 80, 42, 183, 40, 92, 186, 230, 229, 118, 202, 212, 214, 83, 18, 17, 76, 61, 146, 160, 29, 30, 56, 157, 173, 106, 204, 194, 135, 214, 192, 203, 165, 98, 21, 71, 68, 51, 45, 4, 144, 24, 23, 77, 146, 91, 205, 50, 187, 201, 200, 18, 91, 106, 182, 90, 91, 181, 85, 84, 17, 206, 203, 36, 148, 171, 140, 92, 40, 39, 193, 189, 244, 159, 158, 28, 247, 246, 161, 236, 3, 196, 54, 68, 104, 193, 168, 8, 117, 228, 31, 189, 193, 55, 98, 97, 99, 126, 47, 100, 166, 79, 218, 155, 154, 26, 209, 49, 131, 135, 136, 150, 47, 126, 217, 223, 52, 53, 45, 51, 134, 211, 170, 140, 67, 69, 108, 43, 106, 91, 230, 119, 120, 226, 130, 247, 63, 53, 52, 238, 20, 242, 46, 70, 156, 78, 62, 96, 46, 53, 63, 143, 34, 227, 173, 155, 133, 123, 117, 111, 44, 125, 19, 236, 134, 51, 216, 206, 205, 154, 153, 22, 39, 37, 167, 200, 201, 208, 36, 142, 100, 57, 212, 202, 20, 60, 99, 28, 158, 157, 35, 226, 113, 160, 159, 27, 204, 202, 210, 113, 225, 46, 43, 202, 204, 62, 76, 77, 137, 123, 116, 41, 38, 72, 203, 129, 142, 64, 98, 240, 49, 102, 64, 41, 73, 74, 212, 216, 207, 42, 74, 184, 169, 170, 211, 170, 149, 176, 105, 66, 69, 122, 6, 168, 123, 147, 187, 96, 77, 90, 65, 55, 107, 89, 90, 180, 101, 100, 120, 63, 105, 104, 93, 137, 227, 15, 86, 85, 129, 102, 49, 14, 87, 86, 55, 8, 9, 100, 47, 121, 145, 23, 22, 88, 89, 179, 6, 122, 196, 88, 95, 96, 138, 172, 136, 215, 58, 172, 115, 48, 219, 42, 80, 81, 195, 3, 51, 43, 146, 61, 171, 175, 199, 81, 82, 38, 53, 46, 225, 144, 163, 110, 246, 33, 7, 52, 65, 66, 229, 228, 117, 34, 127, 234, 107, 108, 69, 109, 108, 151, 48, 64, 235, 62, 78, 191, 129, 209, 126, 111, 35, 143, 163, 161, 246, 117, 123, 50, 222, 65, 52, 19, 125, 141, 221, 55, 65, 3, 195, 197, 25, 7, 33, 220, 237, 44, 70, 71, 139, 122, 193, 245, 247, 130, 33, 71, 21, 162, 153, 158, 159, 170, 169, 150, 188, 174, 196, 216, 186, 92, 144, 160, 161, 2, 97, 167, 141, 125, 241, 164, 167, 37, 72, 38, 12, 145, 159, 160, 38, 82, 13, 63, 68, 71, 226, 35, 111, 158, 153, 154, 101, 50, 205, 206, 92, 165, 209, 198, 217, 165, 167, 97, 220, 115, 218, 133, 112, 243, 239, 238, 241, 214, 135, 169, 190, 173, 133, 171, 208, 32, 125, 44, 237, 86, 87, 178, 85, 86, 179, 84, 85, 180, 83, 84, 181, 201, 83, 182, 137, 93, 132, 76, 62, 183, 61, 76, 184, 57, 61, 185, 212, 57, 186, 214, 207, 187, 34, 143, 156, 79, 239, 237, 123, 137, 177, 44, 1, 4, 201, 194, 32, 64, 102, 129, 213, 215, 138, 59, 166, 219, 242, 99, 97, 2, 94, 141, 75, 59, 235, 24, 110, 228, 25, 130, 226, 23, 24, 229, 22, 23, 230, 26, 22, 231, 112, 26, 232, 189, 190, 243, 221, 56, 190, 28, 56, 221, 27, 28, 222, 29, 27, 223, 30, 29, 224, 247, 30, 225, 238, 79, 20, 166, 59, 75, 60, 75, 240, 147, 177, 215, 20, 79, 166, 187, 147, 213, 112, 233, 244, 233, 128, 245, 128, 114, 188, 114, 217, 174, 131, 115, 220, 217, 198, 236, 198, 131, 134, 177, 132, 58, 143, 35, 124, 110, 163, 7, 228, 110, 25, 356, 389, 368, 11, 302, 267, 452, 350, 349, 302, 303, 269, 357, 343, 277, 452, 453, 357, 333, 332, 297, 175, 152, 377, 384, 398, 382, 347, 348, 330, 303, 304, 270, 9, 336, 337, 278, 279, 360, 418, 262, 431, 304, 408, 409, 310, 415, 407, 270, 409, 410, 450, 348, 347, 422, 430, 434, 313, 314, 17, 306, 307, 375, 387, 388, 260, 286, 414, 398, 335, 406, 418, 364, 367, 416, 423, 358, 327, 251, 284, 298, 281, 5, 4, 373, 374, 253, 307, 320, 321, 425, 427, 411, 421, 313, 18, 321, 405, 406, 320, 404, 405, 315, 16, 17, 426, 425, 266, 377, 400, 369, 322, 391, 269, 417, 465, 464, 386, 257, 258, 466, 260, 388, 456, 399, 419, 284, 332, 333, 417, 285, 8, 346, 340, 261, 413, 441, 285, 327, 460, 328, 355, 371, 329, 392, 439, 438, 382, 341, 256, 429, 420, 360, 364, 394, 379, 277, 343, 437, 443, 444, 283, 275, 440, 363, 431, 262, 369, 297, 338, 337, 273, 375, 321, 450, 451, 349, 446, 342, 467, 293, 334, 282, 458, 461, 462, 276, 353, 383, 308, 324, 325, 276, 300, 293, 372, 345, 447, 382, 398, 362, 352, 345, 340, 274, 1, 19, 456, 248, 281, 436, 427, 425, 381, 256, 252, 269, 391, 393, 200, 199, 428, 266, 330, 329, 287, 273, 422, 250, 462, 328, 258, 286, 384, 265, 353, 342, 387, 259, 257, 424, 431, 430, 342, 353, 276, 273, 335, 424, 292, 325, 307, 366, 447, 345, 271, 303, 302, 423, 266, 371, 294, 455, 460, 279, 278, 294, 271, 272, 304, 432, 434, 427, 272, 407, 408, 394, 430, 431, 395, 369, 400, 334, 333, 299, 351, 417, 168, 352, 280, 411, 325, 319, 320, 295, 296, 336, 319, 403, 404, 330, 348, 349, 293, 298, 333, 323, 454, 447, 15, 16, 315, 358, 429, 279, 14, 15, 316, 285, 336, 9, 329, 349, 350, 374, 380, 252, 318, 402, 403, 6, 197, 419, 318, 319, 325, 367, 364, 365, 435, 367, 397, 344, 438, 439, 272, 271, 311, 195, 5, 281, 273, 287, 291, 396, 428, 199, 311, 271, 268, 283, 444, 445, 373, 254, 339, 263, 466, 249, 282, 334, 296, 449, 347, 346, 264, 447, 454, 336, 296, 299, 338, 10, 151, 278, 439, 455, 292, 407, 415, 358, 371, 355, 340, 345, 372, 390, 249, 466, 346, 347, 280, 442, 443, 282, 19, 94, 370, 441, 442, 295, 248, 419, 197, 263, 255, 359, 440, 275, 274, 300, 383, 368, 351, 412, 465, 263, 467, 466, 301, 368, 389, 380, 374, 386, 395, 378, 379, 412, 351, 419, 436, 426, 322, 373, 390, 388, 2, 164, 393, 370, 462, 461, 164, 0, 267, 302, 11, 12, 374, 373, 387, 268, 12, 13, 293, 300, 301, 446, 261, 340, 385, 384, 381, 330, 266, 425, 426, 423, 391, 429, 355, 437, 391, 327, 326, 440, 457, 438, 341, 382, 362, 459, 457, 461, 434, 430, 394, 414, 463, 362, 396, 369, 262, 354, 461, 457, 316, 403, 402, 315, 404, 403, 314, 405, 404, 313, 406, 405, 421, 418, 406, 366, 401, 361, 306, 408, 407, 291, 409, 408, 287, 410, 409, 432, 436, 410, 434, 416, 411, 264, 368, 383, 309, 438, 457, 352, 376, 401, 274, 275, 4, 421, 428, 262, 294, 327, 358, 433, 416, 367, 289, 455, 439, 462, 370, 326, 2, 326, 370, 305, 460, 455, 254, 449, 448, 255, 261, 446, 253, 450, 449, 252, 451, 450, 256, 452, 451, 341, 453, 452, 413, 464, 463, 441, 413, 414, 258, 442, 441, 257, 443, 442, 259, 444, 443, 260, 445, 444, 467, 342, 445, 459, 458, 250, 289, 392, 290, 290, 328, 460, 376, 433, 435, 250, 290, 392, 411, 416, 433, 341, 463, 464, 453, 464, 465, 357, 465, 412, 343, 412, 399, 360, 363, 440, 437, 399, 456, 420, 456, 363, 401, 435, 288, 372, 383, 353, 339, 255, 249, 448, 261, 255, 133, 243, 190, 133, 155, 112, 33, 246, 247, 33, 130, 25, 398, 384, 286, 362, 398, 414, 362, 463, 341, 263, 359, 467, 263, 249, 255, 466, 467, 260, 75, 60, 166, 238, 239, 79, 162, 127, 139, 72, 11, 37, 121, 232, 120, 73, 72, 39, 114, 128, 47, 233, 232, 128, 103, 104, 67, 152, 175, 148, 173, 157, 155, 119, 118, 101, 74, 73, 40, 107, 9, 108, 49, 48, 131, 32, 194, 211, 184, 74, 185, 191, 80, 183, 185, 40, 186, 119, 230, 118, 210, 202, 214, 84, 83, 17, 77, 76, 146, 161, 160, 30, 190, 56, 173, 182, 106, 194, 138, 135, 192, 129, 203, 98, 54, 21, 68, 5, 51, 4, 145, 144, 23, 90, 77, 91, 207, 205, 187, 83, 201, 18, 181, 91, 182, 180, 90, 181, 16, 85, 17, 205, 206, 36, 176, 148, 140, 165, 92, 39, 245, 193, 244, 27, 159, 28, 30, 247, 161, 174, 236, 196, 103, 54, 104, 55, 193, 8, 111, 117, 31, 221, 189, 55, 240, 98, 99, 142, 126, 100, 219, 166, 218, 112, 155, 26, 198, 209, 131, 169, 135, 150, 114, 47, 217, 224, 223, 53, 220, 45, 134, 32, 211, 140, 109, 67, 108, 146, 43, 91, 231, 230, 120, 113, 226, 247, 105, 63, 52, 241, 238, 242, 124, 46, 156, 95, 78, 96, 70, 46, 63, 116, 143, 227, 116, 123, 111, 1, 44, 19, 3, 236, 51, 207, 216, 205, 26, 154, 22, 165, 39, 167, 199, 200, 208, 101, 36, 100, 43, 57, 202, 242, 20, 99, 56, 28, 157, 124, 35, 113, 29, 160, 27, 211, 204, 210, 124, 113, 46, 106, 43, 204, 96, 62, 77, 227, 137, 116, 73, 41, 72, 36, 203, 142, 235, 64, 240, 48, 49, 64, 42, 41, 74, 214, 212, 207, 183, 42, 184, 210, 169, 211, 140, 170, 176, 104, 105, 69, 193, 122, 168, 50, 123, 187, 89, 96, 90, 66, 65, 107, 179, 89, 180, 119, 101, 120, 68, 63, 104, 234, 93, 227, 16, 15, 85, 209, 129, 49, 15, 14, 86, 107, 55, 9, 120, 100, 121, 153, 145, 22, 178, 88, 179, 197, 6, 196, 89, 88, 96, 135, 138, 136, 138, 215, 172, 218, 115, 219, 41, 42, 81, 5, 195, 51, 57, 43, 61, 208, 171, 199, 41, 81, 38, 224, 53, 225, 24, 144, 110, 105, 52, 66, 118, 229, 117, 227, 34, 234, 66, 107, 69, 10, 109, 151, 219, 48, 235, 183, 62, 191, 142, 129, 126, 116, 111, 143, 7, 163, 246, 118, 117, 50, 223, 222, 52, 94, 19, 141, 222, 221, 65, 196, 3, 197, 45, 220, 44, 156, 70, 139, 188, 122, 245, 139, 71, 162, 145, 153, 159, 149, 170, 150, 122, 188, 196, 206, 216, 92, 163, 144, 161, 164, 2, 167, 242, 141, 241, 0, 164, 37, 11, 72, 12, 144, 145, 160, 12, 38, 13, 70, 63, 71, 31, 226, 111, 157, 158, 154, 36, 101, 205, 203, 206, 165, 126, 209, 217, 98, 165, 97, 237, 220, 218, 237, 239, 241, 210, 214, 169, 140, 171, 32, 241, 125, 237, 179, 86, 178, 180, 85, 179, 181, 84, 180, 182, 83, 181, 194, 201, 182, 177, 137, 132, 184, 76, 183, 185, 61, 184, 186, 57, 185, 216, 212, 186, 192, 214, 187, 139, 34, 156, 218, 79, 237, 147, 123, 177, 45, 44, 4, 208, 201, 32, 98, 64, 129, 192, 213, 138, 235, 59, 219, 141, 242, 97, 97, 2, 141, 240, 75, 235, 229, 24, 228, 31, 25, 226, 230, 23, 229, 231, 22, 230, 232, 26, 231, 233, 112, 232, 244, 189, 243, 189, 221, 190, 222, 28, 221, 223, 27, 222, 224, 29, 223, 225, 30, 224, 113, 247, 225, 99, 60, 240, 213, 147, 215, 60, 20, 166, 192, 187, 213, 243, 112, 244, 244, 233, 245, 245, 128, 188, 188, 114, 174, 134, 131, 220, 174, 217, 236, 236, 198, 134, 215, 177, 58, 156, 143, 124, 25, 110, 7, 31, 228, 25, 264, 356, 368, 0, 11, 267, 451, 452, 349, 267, 302, 269, 350, 357, 277, 350, 452, 357, 299, 333, 297, 396, 175, 377, 381, 384, 382, 280, 347, 330, 269, 303, 270, 151, 9, 337, 344, 278, 360, 424, 418, 431, 270, 304, 409, 272, 310, 407, 322, 270, 410, 449, 450, 347, 432, 422, 434, 18, 313, 17, 291, 306, 375, 259, 387, 260, 424, 335, 418, 434, 364, 416, 391, 423, 327, 301, 251, 298, 275, 281, 4, 254, 373, 253, 375, 307, 321, 280, 425, 411, 200, 421, 18, 335, 321, 406, 321, 320, 405, 314, 315, 17, 423, 426, 266, 396, 377, 369, 270, 322, 269, 413, 417, 464, 385, 386, 258, 248, 456, 419, 298, 284, 333, 168, 417, 8, 448, 346, 261, 417, 413, 285, 326, 327, 328, 277, 355, 329, 309, 392, 438, 381, 382, 256, 279, 429, 360, 365, 364, 379, 355, 277, 437, 282, 443, 283, 281, 275, 363, 395, 431, 369, 299, 297, 337, 335, 273, 321, 348, 450, 349, 359, 446, 467, 283, 293, 282, 250, 458, 462, 300, 276, 383, 292, 308, 325, 283, 276, 293, 264, 372, 447, 346, 352, 340, 354, 274, 19, 363, 456, 281, 426, 436, 425, 380, 381, 252, 267, 269, 393, 421, 200, 428, 371, 266, 329, 432, 287, 422, 290, 250, 328, 385, 258, 384, 446, 265, 342, 386, 387, 257, 422, 424, 430, 445, 342, 276, 422, 273, 424, 306, 292, 307, 352, 366, 345, 268, 271, 302, 358, 423, 371, 327, 294, 460, 331, 279, 294, 303, 271, 304, 436, 432, 427, 304, 272, 408, 395, 394, 431, 378, 395, 400, 296, 334, 299, 6, 351, 168, 376, 352, 411, 307, 325, 320, 285, 295, 336, 320, 319, 404, 329, 330, 349, 334, 293, 333, 366, 323, 447, 316, 15, 315, 331, 358, 279, 317, 14, 316, 8, 285, 9, 277, 329, 350, 253, 374, 252, 319, 318, 403, 351, 6, 419, 324, 318, 325, 397, 367, 365, 288, 435, 397, 278, 344, 439, 310, 272, 311, 248, 195, 281, 375, 273, 291, 175, 396, 199, 312, 311, 268, 276, 283, 445, 390, 373, 339, 295, 282, 296, 448, 449, 346, 356, 264, 454, 337, 336, 299, 337, 338, 151, 294, 278, 455, 308, 292, 415, 429, 358, 355, 265, 340, 372, 388, 390, 466, 352, 346, 280, 295, 442, 282, 354, 19, 370, 285, 441, 295, 195, 248, 197, 457, 440, 274, 301, 300, 368, 417, 351, 465, 251, 301, 389, 385, 380, 386, 394, 395, 379, 399, 412, 419, 410, 436, 322, 387, 373, 388, 326, 2, 393, 354, 370, 461, 393, 164, 267, 268, 302, 12, 386, 374, 387, 312, 268, 13, 298, 293, 301, 265, 446, 340, 380, 385, 381, 280, 330, 425, 322, 426, 391, 420, 429, 437, 393, 391, 326, 344, 440, 438, 458, 459, 461, 364, 434, 394, 428, 396, 262, 274, 354, 457, 317, 316, 402, 316, 315, 403, 315, 314, 404, 314, 313, 405, 313, 421, 406, 323, 366, 361, 292, 306, 407, 306, 291, 408, 291, 287, 409, 287, 432, 410, 427, 434, 411, 372, 264, 383, 459, 309, 457, 366, 352, 401, 1, 274, 4, 418, 421, 262, 331, 294, 358, 435, 433, 367, 392, 289, 439, 328, 462, 326, 94, 2, 370, 289, 305, 455, 339, 254, 448, 359, 255, 446, 254, 253, 449, 253, 252, 450, 252, 256, 451, 256, 341, 452, 414, 413, 463, 286, 441, 414, 286, 258, 441, 258, 257, 442, 257, 259, 443, 259, 260, 444, 260, 467, 445, 309, 459, 250, 305, 289, 290, 305, 290, 460, 401, 376, 435, 309, 250, 392, 376, 411, 433, 453, 341, 464, 357, 453, 465, 343, 357, 412, 437, 343, 399, 344, 360, 440, 420, 437, 456, 360, 420, 363, 361, 401, 288, 265, 372, 353, 390, 339, 249, 339, 448, 255];
            const UVS = [.499976992607117, .34746599197387695, .500025987625122, .45251297950744596, .499974012374878, .397628009319305, .482113003730774, .528020977973938, .500150978565216, .47284400463104204, .499909996986389, .5017470121383669, .499523013830185, .59893798828125, .289712011814117, .6192359924316411, .499954998493195, .687601983547211, .499987006187439, .730081021785736, .500023007392883, .892949998378754, .500023007392883, .33376598358154297, .5000159740448, .320775985717773, .500023007392883, .30765199661254905, .499976992607117, .30472201108932495, .499976992607117, .29406601190567005, .499976992607117, .280614972114563, .499976992607117, .262980997562408, .499967992305756, .21862900257110596, .499816000461578, .43701899051666304, .473773002624512, .42609000205993697, .104906998574734, .745859026908875, .365929991006851, .590424001216888, .338757991790771, .58697497844696, .311120003461838, .590539991855621, .274657994508743, .6108689904212949, .393361985683441, .596293985843658, .345234006643295, .655988991260529, .370094001293182, .6539239883422849, .319321990013123, .652734994888306, .297903001308441, .646408975124359, .24779200553894, .589190006256104, .396889001131058, .15724498033523604, .280097991228104, .6244000196456909, .106310002505779, .6000440120697019, .2099249958992, .6086469888687129, .355807989835739, .46559399366378795, .471751004457474, .34959602355957, .474155008792877, .319808006286621, .439785003662109, .342770993709564, .414617002010345, .33345901966095004, .450374007225037, .319139003753662, .428770989179611, .31730902194976796, .374971002340317, .272194981575012, .486716985702515, .452371001243591, .485300987958908, .47260499000549305, .257764995098114, .685509979724884, .401223003864288, .544827997684479, .429818987846375, .451385021209717, .421351999044418, .466259002685547, .276895999908447, .467943012714386, .483370006084442, .500413000583649, .33721199631691, .7171170115470891, .296391993761063, .706757009029388, .169294998049736, .806186020374298, .447580009698868, .697390019893646, .392390012741089, .646112024784088, .354490011930466, .30321598052978505, .067304998636246, .269894957542419, .442739009857178, .427173972129822, .457098007202148, .415207982063293, .381974011659622, .305289030075073, .392388999462128, .305796980857849, .277076005935669, .728067994117737, .422551989555359, .436766982078552, .385919004678726, .718635976314545, .383103013038635, .744159996509552, .331431001424789, .880285978317261, .229923993349075, .767997026443481, .364500999450684, .810886025428772, .229622006416321, .700459003448486, .173287004232407, .721252024173737, .472878992557526, .33380198478698697, .446828007698059, .331472992897034, .422762006521225, .32611000537872303, .445307999849319, .41993403434753396, .388103008270264, .306038975715637, .403039008378983, .293460011482239, .403629004955292, .306046962738037, .460041999816895, .44286096096038796, .431158006191254, .307633996009827, .452181994915009, .307633996009827, .475387006998062, .307633996009827, .465828001499176, .22080999612808205, .472328990697861, .263774037361145, .473087012767792, .282142996788025, .473122000694275, .295374035835266, .473033010959625, .30472201108932495, .427942007780075, .30472201108932495, .426479011774063, .29646003246307395, .423162013292313, .28815400600433305, .4183090031147, .27993702888488803, .390094995498657, .360427021980286, .013953999616206, .439965963363647, .499913990497589, .41985297203064, .413199990987778, .30460000038146995, .409626007080078, .29817700386047397, .468080013990402, .398465037345886, .422728985548019, .414014995098114, .463079988956451, .406216025352478, .37211999297142, .52658599615097, .334562003612518, .5039269924163821, .411671012639999, .45303499698638905, .242175996303558, .85232400894165, .290776997804642, .798554003238678, .327338010072708, .7434729933738711, .399509996175766, .251078963279724, .441727995872498, .738323986530304, .429764986038208, .8121659755706789, .412198007106781, .891098976135254, .288955003023148, .601047992706299, .218936994671822, .564589023590088, .41278201341629, .601029992103577, .257135003805161, .644559979438782, .427684992551804, .562039017677307, .448339998722076, .46306395530700695, .178560003638268, .54244601726532, .247308000922203, .542806029319763, .286267012357712, .532325029373169, .332827985286713, .5392879843711851, .368755996227264, .552793025970459, .398963987827301, .567345023155212, .476410001516342, .594193994998932, .189241006970406, .47607600688934304, .228962004184723, .651049017906189, .490725994110107, .43759900331497203, .404670000076294, .514867007732391, .019469000399113, .598435997962952, .426243007183075, .5795689821243291, .396993011236191, .451202988624573, .266469985246658, .6230229735374451, .439121007919312, .48104202747345004, .032313998788595, .355643033981323, .419054001569748, .612845003604889, .462783008813858, .49425303936004605, .238978996872902, .22025501728057895, .198220998048782, .16806197166442904, .107550002634525, .459244966506958, .183610007166862, .259742975234985, .134409993886948, .6663169860839839, .385764002799988, .11684602499008201, .490967005491257, .42062199115753196, .382384985685349, .491427004337311, .174399003386497, .602329015731812, .318785011768341, .60376501083374, .343364000320435, .599403023719788, .396100014448166, .28978300094604503, .187885001301765, .41146200895309404, .430987000465393, .05593502521514904, .318993002176285, .101714968681335, .266247987747192, .130298972129822, .500023007392883, .809423983097076, .499976992607117, .045547008514403964, .366169989109039, .601177990436554, .393207013607025, .6044629812240601, .410373002290726, .608919978141785, .194993004202843, .657898008823395, .388664990663528, .6377159953117371, .365961998701096, .644029021263123, .343364000320435, .6446430087089541, .318785011768341, .64165997505188, .301414996385574, .636843979358673, .058132998645306, .680923998355865, .301414996385574, .612550973892212, .499987989664078, .38156598806381203, .415838003158569, .375804007053375, .445681989192963, .43392300605773904, .465844005346298, .379359006881714, .49992299079895, .648476004600525, .288718998432159, .180054008960724, .335278987884521, .14718002080917403, .440512001514435, .09758102893829301, .128294005990028, .20805901288986195, .408771991729736, .6261060237884519, .455606997013092, .548198997974396, .499877005815506, .09100997447967496, .375436991453171, .07580798864364602, .11421000212431, .38497799634933505, .448662012815475, .30472201108932495, .4480200111866, .295367956161499, .447111994028091, .28419196605682395, .444831997156143, .269205987453461, .430011987686157, .23319101333618197, .406787008047104, .31432700157165505, .400738000869751, .318930983543396, .392399996519089, .32229697704315197, .367855995893478, .33608102798461903, .247923001646996, .39866697788238503, .452769994735718, .579150021076202, .43639200925827, .640112996101379, .416164010763168, .631286025047302, .413385987281799, .307633996009827, .228018000721931, .316428005695343, .468268007040024, .6473289728164671, .411361992359161, .195672988891602, .499989002943039, .530174970626831, .479153990745544, .557345986366272, .499974012374878, .5603629946708679, .432112008333206, .506411015987396, .499886006116867, .13308298587799094, .49991300702095, .17827099561691295, .456548988819122, .18079900741577104, .344549000263214, .254561007022858, .37890899181366, .425989985466003, .374292999505997, .219815015792847, .319687992334366, .42926204204559304, .357154995203018, .395730018615723, .295284003019333, .37841904163360596, .447750002145767, .137522995471954, .410986006259918, .491276979446411, .31395098567009, .22469198703765902, .354128003120422, .187447011470795, .324548006057739, .296007037162781, .189096003770828, .35370004177093495, .279776990413666, .28534197807312, .1338230073452, .317299008369446, .336768001317978, .35526698827743497, .429883986711502, .533478021621704, .455527991056442, .451377034187317, .437114000320435, .441103994846344, .467287987470627, .47007501125335704, .414712011814117, .6647800207138059, .37704598903656, .677222013473511, .344107985496521, .679849028587341, .312875986099243, .67766797542572, .283526003360748, .6668099761009221, .241245999932289, .617214024066925, .102986000478268, .531237006187439, .267612010240555, .575439989566803, .297879010438919, .5668240189552309, .333433985710144, .5661219954490659, .366427004337311, .573884010314941, .396012008190155, .583303987979889, .420121014118195, .58977198600769, .007561000064015, .519222974777222, .432949006557465, .43048202991485596, .458638995885849, .520910978317261, .473466008901596, .45425599813461304, .476087987422943, .43616998195648204, .468472003936768, .444943010807037, .433990985155106, .417638003826141, .483518004417419, .43701601028442405, .482482999563217, .42215096950530995, .42645001411438, .6102010011672969, .438998997211456, .60350501537323, .450067013502121, .599565982818604, .289712011814117, .631747007369995, .276670008897781, .636627018451691, .517862021923065, .528051972389221, .710287988185883, .6192359924316411, .526226997375488, .42609000205993697, .895093023777008, .745859026908875, .634069979190826, .590424001216888, .661242008209229, .58697497844696, .688880026340485, .590539991855621, .725341975688934, .6108689904212949, .606630027294159, .5962949991226201, .654766023159027, .655988991260529, .629905998706818, .6539239883422849, .680678009986877, .652734994888306, .702096998691559, .646408975124359, .75221198797226, .589195013046265, .602918028831482, .15713703632354703, .719901978969574, .6244000196456909, .893692970275879, .600040018558502, .790081977844238, .608645975589752, .643998026847839, .465512037277222, .528249025344849, .34959602355957, .525849997997284, .31980895996093806, .560214996337891, .342770993709564, .585384011268616, .33345901966095004, .549625992774963, .319139003753662, .57122802734375, .317308008670807, .624852001667023, .27190101146698, .513050019741058, .45271801948547397, .51509702205658, .472748041152954, .742246985435486, .685492992401123, .598631024360657, .545020997524261, .570338010787964, .451424956321716, .578631997108459, .46637701988220204, .723087012767792, .467945992946625, .516445994377136, .500361025333405, .662801027297974, .717082023620605, .70362401008606, .706728994846344, .830704987049103, .806186020374298, .552385985851288, .697431981563568, .607609987258911, .646112024784088, .645429015159607, .30329298973083496, .932694971561432, .269894957542419, .557260990142822, .427173972129822, .542901992797852, .415207982063293, .6180260181427, .305289030075073, .607590973377228, .305796980857849, .722943007946014, .7280369997024541, .577413976192474, .43683302402496305, .614082992076874, .7186130285263059, .616907000541687, .744113981723785, .668509006500244, .880086004734039, .770092010498047, .767979025840759, .635536015033722, .8107510209083559, .77039098739624, .7004439830780029, .826722025871277, .7212449908256531, .527121007442474, .33380198478698697, .553171992301941, .331472992897034, .577238023281097, .32611000537872303, .554691970348358, .41993403434753396, .611896991729736, .306038975715637, .59696102142334, .293460011482239, .596370995044708, .306046962738037, .539958000183105, .44286096096038796, .568841993808746, .307633996009827, .547818005084991, .307633996009827, .52461302280426, .307633996009827, .534089982509613, .22085899114608798, .527670979499817, .263774037361145, .526912987232208, .282142996788025, .526877999305725, .295374035835266, .526966989040375, .30472201108932495, .572058022022247, .30472201108932495, .573521018028259, .29646003246307395, .57683801651001, .28815400600433305, .581691026687622, .27993702888488803, .609944999217987, .36009001731872603, .986046016216278, .439965963363647, .5867999792099, .30460000038146995, .590372025966644, .29817700386047397, .531915009021759, .398463010787964, .577268004417419, .414065003395081, .536915004253387, .406213998794556, .627542972564697, .526647984981537, .665585994720459, .5040490031242371, .588353991508484, .45313799381256104, .757824003696442, .85232400894165, .709249973297119, .798492014408112, .672684013843536, .743418991565704, .600408971309662, .25099503993988004, .55826598405838, .738327980041504, .570303976535797, .812129020690918, .588165998458862, .890955984592438, .711045026779175, .601047992706299, .781069993972778, .564594984054565, .587247014045715, .601068019866943, .742869973182678, .644554018974304, .572156012058258, .562348008155823, .55186802148819, .46342998743057295, .821442008018494, .542443990707397, .752701997756958, .542818009853363, .71375697851181, .532373011112213, .66711300611496, .539327025413513, .631101012229919, .552846014499664, .6008620262146, .567526996135712, .523481011390686, .5943729877471919, .810747981071472, .476073980331421, .771045982837677, .6510409712791441, .509127020835876, .43728196620941195, .595292985439301, .514976024627686, .980530977249146, .598435997962952, .573499977588654, .579999983310699, .602994978427887, .45131200551986705, .733529984951019, .6230229735374451, .560611009597778, .48098301887512196, .967685997486115, .355643033981323, .580985009670258, .612839996814728, .537728011608124, .494614958763123, .760966002941132, .22024703025817904, .801778972148895, .16806197166442904, .892440974712372, .45923900604248, .816350996494293, .259739995002747, .865594983100891, .666312992572784, .614073991775513, .11675399541854903, .508952975273132, .42056202888488803, .617941975593567, .49168395996093806, .825608015060425, .602325022220612, .681214988231659, .60376501083374, .656635999679565, .599403023719788, .603900015354156, .28978300094604503, .81208598613739, .41146099567413297, .56801301240921, .05543500185012795, .681007981300354, .101714968681335, .733752012252808, .130298972129822, .633830010890961, .601177990436554, .606792986392975, .6044629812240601, .589659988880157, .6089379787445071, .805015981197357, .657891988754272, .611334979534149, .6377159953117371, .634037971496582, .644029021263123, .656635999679565, .6446430087089541, .681214988231659, .64165997505188, .698584973812103, .636843979358673, .941866993904114, .680923998355865, .698584973812103, .612550973892212, .584177017211914, .375892996788025, .554318010807037, .43392300605773904, .534153997898102, .37935996055603005, .711217999458313, .18002498149871804, .664629995822906, .14712899923324596, .559099972248077, .09736800193786599, .871706008911133, .20805901288986195, .591234028339386, .6261060237884519, .544341027736664, .548416018486023, .624562978744507, .07580798864364602, .88577002286911, .384971022605896, .551338016986847, .30472201108932495, .551980018615723, .295367956161499, .552887976169586, .28419196605682395, .555167973041534, .269205987453461, .569944024085999, .23296499252319303, .593203008174896, .31432402133941695, .599261999130249, .318930983543396, .607599973678589, .32229697704315197, .631937980651855, .33649998903274503, .752032995223999, .398684978485107, .547226011753082, .579604983329773, .563543975353241, .640172004699707, .583841025829315, .631286025047302, .586614012718201, .307633996009827, .771915018558502, .31642198562622104, .531597018241882, .647517025470734, .588370978832245, .19555902481079102, .52079701423645, .5574349761009221, .567984998226166, .5065209865570071, .543282985687256, .18074500560760498, .655317008495331, .25448501110076904, .621008992195129, .42598199844360396, .625559985637665, .21968799829483, .680198013782501, .42928099632263195, .64276397228241, .39566200971603405, .704662978649139, .378470003604889, .552012026309967, .13740801811218295, .589071989059448, .491362988948822, .685944974422455, .224642992019653, .645735025405884, .18735998868942305, .675342977046967, .29602199792861905, .810858011245728, .35369503498077404, .72012197971344, .28533303737640403, .866151988506317, .31729501485824596, .663187026977539, .35540300607681297, .570082008838654, .533674001693726, .544561982154846, .451624035835266, .562758982181549, .441215038299561, .531987011432648, .469859957695007, .585271000862122, .664822995662689, .622952997684479, .67722100019455, .655896008014679, .679836988449097, .687132000923157, .677654027938843, .716481983661652, .666799008846283, .758756995201111, .617213010787964, .897013008594513, .531230986118317, .732392013072968, .575452983379364, .70211398601532, .566837012767792, .66652500629425, .566133975982666, .633504986763, .5739120244979861, .603875994682312, .583413004875183, .579657971858978, .590054988861084, .992439985275269, .519222974777222, .567192018032074, .43058001995086703, .54136598110199, .521100997924805, .526564002037048, .453881978988647, .523913025856018, .43616998195648204, .531529009342194, .444943010807037, .566035985946655, .41767096519470204, .51631098985672, .43694603443145796, .5174720287323, .42212295532226596, .573594987392426, .610193014144897, .560697972774506, .604668021202087, .549755990505219, .6002489924430849, .710287988185883, .631747007369995, .723330020904541, .636627018451691];
        </script>
        <script type="module">
            import * as THREE from 'https://cdn.bootcdn.net/ajax/libs/three.js/0.147.0/three.module.min.js';
            import {
                AnimationClip,
                Bone,
                Box3,
                BufferAttribute,
                BufferGeometry,
                ClampToEdgeWrapping,
                Color,
                DirectionalLight,
                DoubleSide,
                FileLoader,
                FrontSide,
                Group,
                ImageBitmapLoader,
                InstancedMesh,
                InterleavedBuffer,
                InterleavedBufferAttribute,
                Interpolant,
                InterpolateDiscrete,
                InterpolateLinear,
                Line,
                LineBasicMaterial,
                LineLoop,
                LineSegments,
                LinearFilter,
                LinearMipmapLinearFilter,
                LinearMipmapNearestFilter,
                Loader,
                LoaderUtils,
                Material,
                MathUtils,
                Matrix4,
                Mesh,
                MeshBasicMaterial,
                MeshPhysicalMaterial,
                MeshStandardMaterial,
                MirroredRepeatWrapping,
                NearestFilter,
                NearestMipmapLinearFilter,
                NearestMipmapNearestFilter,
                NumberKeyframeTrack,
                Object3D,
                OrthographicCamera,
                PerspectiveCamera,
                PointLight,
                Points,
                PointsMaterial,
                PropertyBinding,
                Quaternion,
                QuaternionKeyframeTrack,
                RepeatWrapping,
                Skeleton,
                SkinnedMesh,
                Sphere,
                SpotLight,
                Texture,
                TextureLoader,
                TriangleFanDrawMode,
                TriangleStripDrawMode,
                Vector2,
                Vector3,
                VectorKeyframeTrack,
                sRGBEncoding
            } from 'https://cdn.bootcdn.net/ajax/libs/three.js/0.147.0/three.module.min.js';

            class GLTFLoader extends Loader {

                constructor(manager) {

                    super(manager);

                    this.dracoLoader = null;
                    this.ktx2Loader = null;
                    this.meshoptDecoder = null;

                    this.pluginCallbacks = [];

                    this.register(function (parser) {

                        return new GLTFMaterialsClearcoatExtension(parser);

                    });

                    this.register(function (parser) {

                        return new GLTFTextureBasisUExtension(parser);

                    });

                    this.register(function (parser) {

                        return new GLTFTextureWebPExtension(parser);

                    });

                    this.register(function (parser) {

                        return new GLTFMaterialsSheenExtension(parser);

                    });

                    this.register(function (parser) {

                        return new GLTFMaterialsTransmissionExtension(parser);

                    });

                    this.register(function (parser) {

                        return new GLTFMaterialsVolumeExtension(parser);

                    });

                    this.register(function (parser) {

                        return new GLTFMaterialsIorExtension(parser);

                    });

                    this.register(function (parser) {

                        return new GLTFMaterialsEmissiveStrengthExtension(parser);

                    });

                    this.register(function (parser) {

                        return new GLTFMaterialsSpecularExtension(parser);

                    });

                    this.register(function (parser) {

                        return new GLTFMaterialsIridescenceExtension(parser);

                    });

                    this.register(function (parser) {

                        return new GLTFLightsExtension(parser);

                    });

                    this.register(function (parser) {

                        return new GLTFMeshoptCompression(parser);

                    });

                    this.register(function (parser) {

                        return new GLTFMeshGpuInstancing(parser);

                    });

                }

                load(url, onLoad, onProgress, onError) {

                    const scope = this;

                    let resourcePath;

                    if (this.resourcePath !== '') {

                        resourcePath = this.resourcePath;

                    } else if (this.path !== '') {

                        resourcePath = this.path;

                    } else {

                        resourcePath = LoaderUtils.extractUrlBase(url);

                    }

                    // Tells the LoadingManager to track an extra item, which resolves after
                    // the model is fully loaded. This means the count of items loaded will
                    // be incorrect, but ensures manager.onLoad() does not fire early.
                    this.manager.itemStart(url);

                    const _onError = function (e) {

                        if (onError) {

                            onError(e);

                        } else {

                            console.error(e);

                        }

                        scope.manager.itemError(url);
                        scope.manager.itemEnd(url);

                    };

                    const loader = new FileLoader(this.manager);

                    loader.setPath(this.path);
                    loader.setResponseType('arraybuffer');
                    loader.setRequestHeader(this.requestHeader);
                    loader.setWithCredentials(this.withCredentials);

                    loader.load(url, function (data) {

                        try {

                            scope.parse(data, resourcePath, function (gltf) {

                                onLoad(gltf);

                                scope.manager.itemEnd(url);

                            }, _onError);

                        } catch (e) {

                            _onError(e);

                        }

                    }, onProgress, _onError);

                }

                setDRACOLoader(dracoLoader) {

                    this.dracoLoader = dracoLoader;
                    return this;

                }

                setDDSLoader() {

                    throw new Error(

                        'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'

                    );

                }

                setKTX2Loader(ktx2Loader) {

                    this.ktx2Loader = ktx2Loader;
                    return this;

                }

                setMeshoptDecoder(meshoptDecoder) {

                    this.meshoptDecoder = meshoptDecoder;
                    return this;

                }

                register(callback) {

                    if (this.pluginCallbacks.indexOf(callback) === - 1) {

                        this.pluginCallbacks.push(callback);

                    }

                    return this;

                }

                unregister(callback) {

                    if (this.pluginCallbacks.indexOf(callback) !== - 1) {

                        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);

                    }

                    return this;

                }

                parse(data, path, onLoad, onError) {

                    let json;
                    const extensions = {};
                    const plugins = {};

                    if (typeof data === 'string') {

                        json = JSON.parse(data);

                    } else if (data instanceof ArrayBuffer) {

                        const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));

                        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {

                            try {

                                extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);

                            } catch (error) {

                                if (onError) onError(error);
                                return;

                            }

                            json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);

                        } else {

                            json = JSON.parse(LoaderUtils.decodeText(new Uint8Array(data)));

                        }

                    } else {

                        json = data;

                    }

                    if (json.asset === undefined || json.asset.version[0] < 2) {

                        if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));
                        return;

                    }

                    const parser = new GLTFParser(json, {

                        path: path || this.resourcePath || '',
                        crossOrigin: this.crossOrigin,
                        requestHeader: this.requestHeader,
                        manager: this.manager,
                        ktx2Loader: this.ktx2Loader,
                        meshoptDecoder: this.meshoptDecoder

                    });

                    parser.fileLoader.setRequestHeader(this.requestHeader);

                    for (let i = 0; i < this.pluginCallbacks.length; i++) {

                        const plugin = this.pluginCallbacks[i](parser);
                        plugins[plugin.name] = plugin;

                        // Workaround to avoid determining as unknown extension
                        // in addUnknownExtensionsToUserData().
                        // Remove this workaround if we move all the existing
                        // extension handlers to plugin system
                        extensions[plugin.name] = true;

                    }

                    if (json.extensionsUsed) {

                        for (let i = 0; i < json.extensionsUsed.length; ++i) {

                            const extensionName = json.extensionsUsed[i];
                            const extensionsRequired = json.extensionsRequired || [];

                            switch (extensionName) {

                                case EXTENSIONS.KHR_MATERIALS_UNLIT:
                                    extensions[extensionName] = new GLTFMaterialsUnlitExtension();
                                    break;

                                case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                                    extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
                                    break;

                                case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                                    extensions[extensionName] = new GLTFTextureTransformExtension();
                                    break;

                                case EXTENSIONS.KHR_MESH_QUANTIZATION:
                                    extensions[extensionName] = new GLTFMeshQuantizationExtension();
                                    break;

                                default:

                                    if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {

                                        console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');

                                    }

                            }

                        }

                    }

                    parser.setExtensions(extensions);
                    parser.setPlugins(plugins);
                    parser.parse(onLoad, onError);

                }

                parseAsync(data, path) {

                    const scope = this;

                    return new Promise(function (resolve, reject) {

                        scope.parse(data, path, resolve, reject);

                    });

                }

            }

            /* GLTFREGISTRY */

            function GLTFRegistry() {

                let objects = {};

                return {

                    get: function (key) {

                        return objects[key];

                    },

                    add: function (key, object) {

                        objects[key] = object;

                    },

                    remove: function (key) {

                        delete objects[key];

                    },

                    removeAll: function () {

                        objects = {};

                    }

                };

            }

            /*********************************/
            /********** EXTENSIONS ***********/
            /*********************************/

            const EXTENSIONS = {
                KHR_BINARY_GLTF: 'KHR_binary_glTF',
                KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
                KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
                KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
                KHR_MATERIALS_IOR: 'KHR_materials_ior',
                KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
                KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
                KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
                KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
                KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
                KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
                KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
                KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
                KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
                KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
                EXT_TEXTURE_WEBP: 'EXT_texture_webp',
                EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
                EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'
            };

            /**
             * Punctual Lights Extension
             *
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
             */
            class GLTFLightsExtension {

                constructor(parser) {

                    this.parser = parser;
                    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

                    // Object3D instance caches
                    this.cache = { refs: {}, uses: {} };

                }

                _markDefs() {

                    const parser = this.parser;
                    const nodeDefs = this.parser.json.nodes || [];

                    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {

                        const nodeDef = nodeDefs[nodeIndex];

                        if (nodeDef.extensions
                            && nodeDef.extensions[this.name]
                            && nodeDef.extensions[this.name].light !== undefined) {

                            parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);

                        }

                    }

                }

                _loadLight(lightIndex) {

                    const parser = this.parser;
                    const cacheKey = 'light:' + lightIndex;
                    let dependency = parser.cache.get(cacheKey);

                    if (dependency) return dependency;

                    const json = parser.json;
                    const extensions = (json.extensions && json.extensions[this.name]) || {};
                    const lightDefs = extensions.lights || [];
                    const lightDef = lightDefs[lightIndex];
                    let lightNode;

                    const color = new Color(0xffffff);

                    if (lightDef.color !== undefined) color.fromArray(lightDef.color);

                    const range = lightDef.range !== undefined ? lightDef.range : 0;

                    switch (lightDef.type) {

                        case 'directional':
                            lightNode = new DirectionalLight(color);
                            lightNode.target.position.set(0, 0, - 1);
                            lightNode.add(lightNode.target);
                            break;

                        case 'point':
                            lightNode = new PointLight(color);
                            lightNode.distance = range;
                            break;

                        case 'spot':
                            lightNode = new SpotLight(color);
                            lightNode.distance = range;
                            // Handle spotlight properties.
                            lightDef.spot = lightDef.spot || {};
                            lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
                            lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
                            lightNode.angle = lightDef.spot.outerConeAngle;
                            lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
                            lightNode.target.position.set(0, 0, - 1);
                            lightNode.add(lightNode.target);
                            break;

                        default:
                            throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type);

                    }

                    // Some lights (e.g. spot) default to a position other than the origin. Reset the position
                    // here, because node-level parsing will only override position if explicitly specified.
                    lightNode.position.set(0, 0, 0);

                    lightNode.decay = 2;

                    assignExtrasToUserData(lightNode, lightDef);

                    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;

                    lightNode.name = parser.createUniqueName(lightDef.name || ('light_' + lightIndex));

                    dependency = Promise.resolve(lightNode);

                    parser.cache.add(cacheKey, dependency);

                    return dependency;

                }

                getDependency(type, index) {

                    if (type !== 'light') return;

                    return this._loadLight(index);

                }

                createNodeAttachment(nodeIndex) {

                    const self = this;
                    const parser = this.parser;
                    const json = parser.json;
                    const nodeDef = json.nodes[nodeIndex];
                    const lightDef = (nodeDef.extensions && nodeDef.extensions[this.name]) || {};
                    const lightIndex = lightDef.light;

                    if (lightIndex === undefined) return null;

                    return this._loadLight(lightIndex).then(function (light) {

                        return parser._getNodeRef(self.cache, lightIndex, light);

                    });

                }

            }

            /**
             * Unlit Materials Extension
             *
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
             */
            class GLTFMaterialsUnlitExtension {

                constructor() {

                    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

                }

                getMaterialType() {

                    return MeshBasicMaterial;

                }

                extendParams(materialParams, materialDef, parser) {

                    const pending = [];

                    materialParams.color = new Color(1.0, 1.0, 1.0);
                    materialParams.opacity = 1.0;

                    const metallicRoughness = materialDef.pbrMetallicRoughness;

                    if (metallicRoughness) {

                        if (Array.isArray(metallicRoughness.baseColorFactor)) {

                            const array = metallicRoughness.baseColorFactor;

                            materialParams.color.fromArray(array);
                            materialParams.opacity = array[3];

                        }

                        if (metallicRoughness.baseColorTexture !== undefined) {

                            pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, sRGBEncoding));

                        }

                    }

                    return Promise.all(pending);

                }

            }

            /**
             * Materials Emissive Strength Extension
             *
             * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md
             */
            class GLTFMaterialsEmissiveStrengthExtension {

                constructor(parser) {

                    this.parser = parser;
                    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;

                }

                extendMaterialParams(materialIndex, materialParams) {

                    const parser = this.parser;
                    const materialDef = parser.json.materials[materialIndex];

                    if (!materialDef.extensions || !materialDef.extensions[this.name]) {

                        return Promise.resolve();

                    }

                    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;

                    if (emissiveStrength !== undefined) {

                        materialParams.emissiveIntensity = emissiveStrength;

                    }

                    return Promise.resolve();

                }

            }

            /**
             * Clearcoat Materials Extension
             *
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
             */
            class GLTFMaterialsClearcoatExtension {

                constructor(parser) {

                    this.parser = parser;
                    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

                }

                getMaterialType(materialIndex) {

                    const parser = this.parser;
                    const materialDef = parser.json.materials[materialIndex];

                    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;

                    return MeshPhysicalMaterial;

                }

                extendMaterialParams(materialIndex, materialParams) {

                    const parser = this.parser;
                    const materialDef = parser.json.materials[materialIndex];

                    if (!materialDef.extensions || !materialDef.extensions[this.name]) {

                        return Promise.resolve();

                    }

                    const pending = [];

                    const extension = materialDef.extensions[this.name];

                    if (extension.clearcoatFactor !== undefined) {

                        materialParams.clearcoat = extension.clearcoatFactor;

                    }

                    if (extension.clearcoatTexture !== undefined) {

                        pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));

                    }

                    if (extension.clearcoatRoughnessFactor !== undefined) {

                        materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

                    }

                    if (extension.clearcoatRoughnessTexture !== undefined) {

                        pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));

                    }

                    if (extension.clearcoatNormalTexture !== undefined) {

                        pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));

                        if (extension.clearcoatNormalTexture.scale !== undefined) {

                            const scale = extension.clearcoatNormalTexture.scale;

                            materialParams.clearcoatNormalScale = new Vector2(scale, scale);

                        }

                    }

                    return Promise.all(pending);

                }

            }

            /**
             * Iridescence Materials Extension
             *
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence
             */
            class GLTFMaterialsIridescenceExtension {

                constructor(parser) {

                    this.parser = parser;
                    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;

                }

                getMaterialType(materialIndex) {

                    const parser = this.parser;
                    const materialDef = parser.json.materials[materialIndex];

                    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;

                    return MeshPhysicalMaterial;

                }

                extendMaterialParams(materialIndex, materialParams) {

                    const parser = this.parser;
                    const materialDef = parser.json.materials[materialIndex];

                    if (!materialDef.extensions || !materialDef.extensions[this.name]) {

                        return Promise.resolve();

                    }

                    const pending = [];

                    const extension = materialDef.extensions[this.name];

                    if (extension.iridescenceFactor !== undefined) {

                        materialParams.iridescence = extension.iridescenceFactor;

                    }

                    if (extension.iridescenceTexture !== undefined) {

                        pending.push(parser.assignTexture(materialParams, 'iridescenceMap', extension.iridescenceTexture));

                    }

                    if (extension.iridescenceIor !== undefined) {

                        materialParams.iridescenceIOR = extension.iridescenceIor;

                    }

                    if (materialParams.iridescenceThicknessRange === undefined) {

                        materialParams.iridescenceThicknessRange = [100, 400];

                    }

                    if (extension.iridescenceThicknessMinimum !== undefined) {

                        materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;

                    }

                    if (extension.iridescenceThicknessMaximum !== undefined) {

                        materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;

                    }

                    if (extension.iridescenceThicknessTexture !== undefined) {

                        pending.push(parser.assignTexture(materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture));

                    }

                    return Promise.all(pending);

                }

            }

            /**
             * Sheen Materials Extension
             *
             * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
             */
            class GLTFMaterialsSheenExtension {

                constructor(parser) {

                    this.parser = parser;
                    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;

                }

                getMaterialType(materialIndex) {

                    const parser = this.parser;
                    const materialDef = parser.json.materials[materialIndex];

                    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;

                    return MeshPhysicalMaterial;

                }

                extendMaterialParams(materialIndex, materialParams) {

                    const parser = this.parser;
                    const materialDef = parser.json.materials[materialIndex];

                    if (!materialDef.extensions || !materialDef.extensions[this.name]) {

                        return Promise.resolve();

                    }

                    const pending = [];

                    materialParams.sheenColor = new Color(0, 0, 0);
                    materialParams.sheenRoughness = 0;
                    materialParams.sheen = 1;

                    const extension = materialDef.extensions[this.name];

                    if (extension.sheenColorFactor !== undefined) {

                        materialParams.sheenColor.fromArray(extension.sheenColorFactor);

                    }

                    if (extension.sheenRoughnessFactor !== undefined) {

                        materialParams.sheenRoughness = extension.sheenRoughnessFactor;

                    }

                    if (extension.sheenColorTexture !== undefined) {

                        pending.push(parser.assignTexture(materialParams, 'sheenColorMap', extension.sheenColorTexture, sRGBEncoding));

                    }

                    if (extension.sheenRoughnessTexture !== undefined) {

                        pending.push(parser.assignTexture(materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture));

                    }

                    return Promise.all(pending);

                }

            }

            /**
             * Transmission Materials Extension
             *
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
             * Draft: https://github.com/KhronosGroup/glTF/pull/1698
             */
            class GLTFMaterialsTransmissionExtension {

                constructor(parser) {

                    this.parser = parser;
                    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

                }

                getMaterialType(materialIndex) {

                    const parser = this.parser;
                    const materialDef = parser.json.materials[materialIndex];

                    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;

                    return MeshPhysicalMaterial;

                }

                extendMaterialParams(materialIndex, materialParams) {

                    const parser = this.parser;
                    const materialDef = parser.json.materials[materialIndex];

                    if (!materialDef.extensions || !materialDef.extensions[this.name]) {

                        return Promise.resolve();

                    }

                    const pending = [];

                    const extension = materialDef.extensions[this.name];

                    if (extension.transmissionFactor !== undefined) {

                        materialParams.transmission = extension.transmissionFactor;

                    }

                    if (extension.transmissionTexture !== undefined) {

                        pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture));

                    }

                    return Promise.all(pending);

                }

            }

            /**
             * Materials Volume Extension
             *
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
             */
            class GLTFMaterialsVolumeExtension {

                constructor(parser) {

                    this.parser = parser;
                    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;

                }

                getMaterialType(materialIndex) {

                    const parser = this.parser;
                    const materialDef = parser.json.materials[materialIndex];

                    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;

                    return MeshPhysicalMaterial;

                }

                extendMaterialParams(materialIndex, materialParams) {

                    const parser = this.parser;
                    const materialDef = parser.json.materials[materialIndex];

                    if (!materialDef.extensions || !materialDef.extensions[this.name]) {

                        return Promise.resolve();

                    }

                    const pending = [];

                    const extension = materialDef.extensions[this.name];

                    materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

                    if (extension.thicknessTexture !== undefined) {

                        pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture));

                    }

                    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;

                    const colorArray = extension.attenuationColor || [1, 1, 1];
                    materialParams.attenuationColor = new Color(colorArray[0], colorArray[1], colorArray[2]);

                    return Promise.all(pending);

                }

            }

            /**
             * Materials ior Extension
             *
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
             */
            class GLTFMaterialsIorExtension {

                constructor(parser) {

                    this.parser = parser;
                    this.name = EXTENSIONS.KHR_MATERIALS_IOR;

                }

                getMaterialType(materialIndex) {

                    const parser = this.parser;
                    const materialDef = parser.json.materials[materialIndex];

                    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;

                    return MeshPhysicalMaterial;

                }

                extendMaterialParams(materialIndex, materialParams) {

                    const parser = this.parser;
                    const materialDef = parser.json.materials[materialIndex];

                    if (!materialDef.extensions || !materialDef.extensions[this.name]) {

                        return Promise.resolve();

                    }

                    const extension = materialDef.extensions[this.name];

                    materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;

                    return Promise.resolve();

                }

            }

            /**
             * Materials specular Extension
             *
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
             */
            class GLTFMaterialsSpecularExtension {

                constructor(parser) {

                    this.parser = parser;
                    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;

                }

                getMaterialType(materialIndex) {

                    const parser = this.parser;
                    const materialDef = parser.json.materials[materialIndex];

                    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;

                    return MeshPhysicalMaterial;

                }

                extendMaterialParams(materialIndex, materialParams) {

                    const parser = this.parser;
                    const materialDef = parser.json.materials[materialIndex];

                    if (!materialDef.extensions || !materialDef.extensions[this.name]) {

                        return Promise.resolve();

                    }

                    const pending = [];

                    const extension = materialDef.extensions[this.name];

                    materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

                    if (extension.specularTexture !== undefined) {

                        pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture));

                    }

                    const colorArray = extension.specularColorFactor || [1, 1, 1];
                    materialParams.specularColor = new Color(colorArray[0], colorArray[1], colorArray[2]);

                    if (extension.specularColorTexture !== undefined) {

                        pending.push(parser.assignTexture(materialParams, 'specularColorMap', extension.specularColorTexture, sRGBEncoding));

                    }

                    return Promise.all(pending);

                }

            }

            /**
             * BasisU Texture Extension
             *
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
             */
            class GLTFTextureBasisUExtension {

                constructor(parser) {

                    this.parser = parser;
                    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

                }

                loadTexture(textureIndex) {

                    const parser = this.parser;
                    const json = parser.json;

                    const textureDef = json.textures[textureIndex];

                    if (!textureDef.extensions || !textureDef.extensions[this.name]) {

                        return null;

                    }

                    const extension = textureDef.extensions[this.name];
                    const loader = parser.options.ktx2Loader;

                    if (!loader) {

                        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {

                            throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');

                        } else {

                            // Assumes that the extension is optional and that a fallback texture is present
                            return null;

                        }

                    }

                    return parser.loadTextureImage(textureIndex, extension.source, loader);

                }

            }

            /**
             * WebP Texture Extension
             *
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
             */
            class GLTFTextureWebPExtension {

                constructor(parser) {

                    this.parser = parser;
                    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
                    this.isSupported = null;

                }

                loadTexture(textureIndex) {

                    const name = this.name;
                    const parser = this.parser;
                    const json = parser.json;

                    const textureDef = json.textures[textureIndex];

                    if (!textureDef.extensions || !textureDef.extensions[name]) {

                        return null;

                    }

                    const extension = textureDef.extensions[name];
                    const source = json.images[extension.source];

                    let loader = parser.textureLoader;
                    if (source.uri) {

                        const handler = parser.options.manager.getHandler(source.uri);
                        if (handler !== null) loader = handler;

                    }

                    return this.detectSupport().then(function (isSupported) {

                        if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);

                        if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {

                            throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');

                        }

                        // Fall back to PNG or JPEG.
                        return parser.loadTexture(textureIndex);

                    });

                }

                detectSupport() {

                    if (!this.isSupported) {

                        this.isSupported = new Promise(function (resolve) {

                            const image = new Image();

                            // Lossy test image. Support for lossy images doesn't guarantee support for all
                            // WebP images, unfortunately.
                            image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

                            image.onload = image.onerror = function () {

                                resolve(image.height === 1);

                            };

                        });

                    }

                    return this.isSupported;

                }

            }

            /**
             * meshopt BufferView Compression Extension
             *
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
             */
            class GLTFMeshoptCompression {

                constructor(parser) {

                    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
                    this.parser = parser;

                }

                loadBufferView(index) {

                    const json = this.parser.json;
                    const bufferView = json.bufferViews[index];

                    if (bufferView.extensions && bufferView.extensions[this.name]) {

                        const extensionDef = bufferView.extensions[this.name];

                        const buffer = this.parser.getDependency('buffer', extensionDef.buffer);
                        const decoder = this.parser.options.meshoptDecoder;

                        if (!decoder || !decoder.supported) {

                            if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {

                                throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files');

                            } else {

                                // Assumes that the extension is optional and that fallback buffer data is present
                                return null;

                            }

                        }

                        return buffer.then(function (res) {

                            const byteOffset = extensionDef.byteOffset || 0;
                            const byteLength = extensionDef.byteLength || 0;

                            const count = extensionDef.count;
                            const stride = extensionDef.byteStride;

                            const source = new Uint8Array(res, byteOffset, byteLength);

                            if (decoder.decodeGltfBufferAsync) {

                                return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function (res) {

                                    return res.buffer;

                                });

                            } else {

                                // Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync
                                return decoder.ready.then(function () {

                                    const result = new ArrayBuffer(count * stride);
                                    decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
                                    return result;

                                });

                            }

                        });

                    } else {

                        return null;

                    }

                }

            }

            /**
             * GPU Instancing Extension
             *
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing
             *
             */
            class GLTFMeshGpuInstancing {

                constructor(parser) {

                    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
                    this.parser = parser;

                }

                createNodeMesh(nodeIndex) {

                    const json = this.parser.json;
                    const nodeDef = json.nodes[nodeIndex];

                    if (!nodeDef.extensions || !nodeDef.extensions[this.name] ||
                        nodeDef.mesh === undefined) {

                        return null;

                    }

                    const meshDef = json.meshes[nodeDef.mesh];

                    // No Points or Lines + Instancing support yet

                    for (const primitive of meshDef.primitives) {

                        if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&
                            primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&
                            primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&
                            primitive.mode !== undefined) {

                            return null;

                        }

                    }

                    const extensionDef = nodeDef.extensions[this.name];
                    const attributesDef = extensionDef.attributes;

                    // @TODO: Can we support InstancedMesh + SkinnedMesh?

                    const pending = [];
                    const attributes = {};

                    for (const key in attributesDef) {

                        pending.push(this.parser.getDependency('accessor', attributesDef[key]).then(accessor => {

                            attributes[key] = accessor;
                            return attributes[key];

                        }));

                    }

                    if (pending.length < 1) {

                        return null;

                    }

                    pending.push(this.parser.createNodeMesh(nodeIndex));

                    return Promise.all(pending).then(results => {

                        const nodeObject = results.pop();
                        const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];
                        const count = results[0].count; // All attribute counts should be same
                        const instancedMeshes = [];

                        for (const mesh of meshes) {

                            // Temporal variables
                            const m = new Matrix4();
                            const p = new Vector3();
                            const q = new Quaternion();
                            const s = new Vector3(1, 1, 1);

                            const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);

                            for (let i = 0; i < count; i++) {

                                if (attributes.TRANSLATION) {

                                    p.fromBufferAttribute(attributes.TRANSLATION, i);

                                }

                                if (attributes.ROTATION) {

                                    q.fromBufferAttribute(attributes.ROTATION, i);

                                }

                                if (attributes.SCALE) {

                                    s.fromBufferAttribute(attributes.SCALE, i);

                                }

                                instancedMesh.setMatrixAt(i, m.compose(p, q, s));

                            }

                            // Add instance attributes to the geometry, excluding TRS.
                            for (const attributeName in attributes) {

                                if (attributeName !== 'TRANSLATION' &&
                                    attributeName !== 'ROTATION' &&
                                    attributeName !== 'SCALE') {

                                    mesh.geometry.setAttribute(attributeName, attributes[attributeName]);

                                }

                            }

                            // Just in case
                            Object3D.prototype.copy.call(instancedMesh, mesh);

                            // https://github.com/mrdoob/three.js/issues/18334
                            instancedMesh.frustumCulled = false;
                            this.parser.assignFinalMaterial(instancedMesh);

                            instancedMeshes.push(instancedMesh);

                        }

                        if (nodeObject.isGroup) {

                            nodeObject.clear();

                            nodeObject.add(...instancedMeshes);

                            return nodeObject;

                        }

                        return instancedMeshes[0];

                    });

                }

            }

            /* BINARY EXTENSION */
            const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
            const BINARY_EXTENSION_HEADER_LENGTH = 12;
            const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

            class GLTFBinaryExtension {

                constructor(data) {

                    this.name = EXTENSIONS.KHR_BINARY_GLTF;
                    this.content = null;
                    this.body = null;

                    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);

                    this.header = {
                        magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
                        version: headerView.getUint32(4, true),
                        length: headerView.getUint32(8, true)
                    };

                    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {

                        throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');

                    } else if (this.header.version < 2.0) {

                        throw new Error('THREE.GLTFLoader: Legacy binary file detected.');

                    }

                    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
                    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
                    let chunkIndex = 0;

                    while (chunkIndex < chunkContentsLength) {

                        const chunkLength = chunkView.getUint32(chunkIndex, true);
                        chunkIndex += 4;

                        const chunkType = chunkView.getUint32(chunkIndex, true);
                        chunkIndex += 4;

                        if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {

                            const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
                            this.content = LoaderUtils.decodeText(contentArray);

                        } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {

                            const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
                            this.body = data.slice(byteOffset, byteOffset + chunkLength);

                        }

                        // Clients must ignore chunks with unknown types.

                        chunkIndex += chunkLength;

                    }

                    if (this.content === null) {

                        throw new Error('THREE.GLTFLoader: JSON content not found.');

                    }

                }

            }

            /**
             * DRACO Mesh Compression Extension
             *
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
             */
            class GLTFDracoMeshCompressionExtension {

                constructor(json, dracoLoader) {

                    if (!dracoLoader) {

                        throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');

                    }

                    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
                    this.json = json;
                    this.dracoLoader = dracoLoader;
                    this.dracoLoader.preload();

                }

                decodePrimitive(primitive, parser) {

                    const json = this.json;
                    const dracoLoader = this.dracoLoader;
                    const bufferViewIndex = primitive.extensions[this.name].bufferView;
                    const gltfAttributeMap = primitive.extensions[this.name].attributes;
                    const threeAttributeMap = {};
                    const attributeNormalizedMap = {};
                    const attributeTypeMap = {};

                    for (const attributeName in gltfAttributeMap) {

                        const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();

                        threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];

                    }

                    for (const attributeName in primitive.attributes) {

                        const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();

                        if (gltfAttributeMap[attributeName] !== undefined) {

                            const accessorDef = json.accessors[primitive.attributes[attributeName]];
                            const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];

                            attributeTypeMap[threeAttributeName] = componentType.name;
                            attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;

                        }

                    }

                    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {

                        return new Promise(function (resolve) {

                            dracoLoader.decodeDracoFile(bufferView, function (geometry) {

                                for (const attributeName in geometry.attributes) {

                                    const attribute = geometry.attributes[attributeName];
                                    const normalized = attributeNormalizedMap[attributeName];

                                    if (normalized !== undefined) attribute.normalized = normalized;

                                }

                                resolve(geometry);

                            }, threeAttributeMap, attributeTypeMap);

                        });

                    });

                }

            }

            /**
             * Texture Transform Extension
             *
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
             */
            class GLTFTextureTransformExtension {

                constructor() {

                    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

                }

                extendTexture(texture, transform) {

                    if (transform.texCoord !== undefined) {

                        console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');

                    }

                    if (transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined) {

                        // See https://github.com/mrdoob/three.js/issues/21819.
                        return texture;

                    }

                    texture = texture.clone();

                    if (transform.offset !== undefined) {

                        texture.offset.fromArray(transform.offset);

                    }

                    if (transform.rotation !== undefined) {

                        texture.rotation = transform.rotation;

                    }

                    if (transform.scale !== undefined) {

                        texture.repeat.fromArray(transform.scale);

                    }

                    texture.needsUpdate = true;

                    return texture;

                }

            }

            /**
             * Mesh Quantization Extension
             *
             * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
             */
            class GLTFMeshQuantizationExtension {

                constructor() {

                    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

                }

            }

            /*********************************/
            /********** INTERPOLATION ********/
            /*********************************/

            // Spline Interpolation
            // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
            class GLTFCubicSplineInterpolant extends Interpolant {

                constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {

                    super(parameterPositions, sampleValues, sampleSize, resultBuffer);

                }

                copySampleValue_(index) {

                    // Copies a sample value to the result buffer. See description of glTF
                    // CUBICSPLINE values layout in interpolate_() function below.

                    const result = this.resultBuffer,
                        values = this.sampleValues,
                        valueSize = this.valueSize,
                        offset = index * valueSize * 3 + valueSize;

                    for (let i = 0; i !== valueSize; i++) {

                        result[i] = values[offset + i];

                    }

                    return result;

                }

                interpolate_(i1, t0, t, t1) {

                    const result = this.resultBuffer;
                    const values = this.sampleValues;
                    const stride = this.valueSize;

                    const stride2 = stride * 2;
                    const stride3 = stride * 3;

                    const td = t1 - t0;

                    const p = (t - t0) / td;
                    const pp = p * p;
                    const ppp = pp * p;

                    const offset1 = i1 * stride3;
                    const offset0 = offset1 - stride3;

                    const s2 = - 2 * ppp + 3 * pp;
                    const s3 = ppp - pp;
                    const s0 = 1 - s2;
                    const s1 = s3 - pp + p;

                    // Layout of keyframe output values for CUBICSPLINE animations:
                    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
                    for (let i = 0; i !== stride; i++) {

                        const p0 = values[offset0 + i + stride]; // splineVertex_k
                        const m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)
                        const p1 = values[offset1 + i + stride]; // splineVertex_k+1
                        const m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)

                        result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

                    }

                    return result;

                }

            }

            const _q = new Quaternion();

            class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {

                interpolate_(i1, t0, t, t1) {

                    const result = super.interpolate_(i1, t0, t, t1);

                    _q.fromArray(result).normalize().toArray(result);

                    return result;

                }

            }


            /*********************************/
            /********** INTERNALS ************/
            /*********************************/

            /* CONSTANTS */

            const WEBGL_CONSTANTS = {
                FLOAT: 5126,
                //FLOAT_MAT2: 35674,
                FLOAT_MAT3: 35675,
                FLOAT_MAT4: 35676,
                FLOAT_VEC2: 35664,
                FLOAT_VEC3: 35665,
                FLOAT_VEC4: 35666,
                LINEAR: 9729,
                REPEAT: 10497,
                SAMPLER_2D: 35678,
                POINTS: 0,
                LINES: 1,
                LINE_LOOP: 2,
                LINE_STRIP: 3,
                TRIANGLES: 4,
                TRIANGLE_STRIP: 5,
                TRIANGLE_FAN: 6,
                UNSIGNED_BYTE: 5121,
                UNSIGNED_SHORT: 5123
            };

            const WEBGL_COMPONENT_TYPES = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array
            };

            const WEBGL_FILTERS = {
                9728: NearestFilter,
                9729: LinearFilter,
                9984: NearestMipmapNearestFilter,
                9985: LinearMipmapNearestFilter,
                9986: NearestMipmapLinearFilter,
                9987: LinearMipmapLinearFilter
            };

            const WEBGL_WRAPPINGS = {
                33071: ClampToEdgeWrapping,
                33648: MirroredRepeatWrapping,
                10497: RepeatWrapping
            };

            const WEBGL_TYPE_SIZES = {
                'SCALAR': 1,
                'VEC2': 2,
                'VEC3': 3,
                'VEC4': 4,
                'MAT2': 4,
                'MAT3': 9,
                'MAT4': 16
            };

            const ATTRIBUTES = {
                POSITION: 'position',
                NORMAL: 'normal',
                TANGENT: 'tangent',
                TEXCOORD_0: 'uv',
                TEXCOORD_1: 'uv2',
                COLOR_0: 'color',
                WEIGHTS_0: 'skinWeight',
                JOINTS_0: 'skinIndex',
            };

            const PATH_PROPERTIES = {
                scale: 'scale',
                translation: 'position',
                rotation: 'quaternion',
                weights: 'morphTargetInfluences'
            };

            const INTERPOLATION = {
                CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
                // keyframe track will be initialized with a default interpolation type, then modified.
                LINEAR: InterpolateLinear,
                STEP: InterpolateDiscrete
            };

            const ALPHA_MODES = {
                OPAQUE: 'OPAQUE',
                MASK: 'MASK',
                BLEND: 'BLEND'
            };

            /**
             * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
             */
            function createDefaultMaterial(cache) {

                if (cache['DefaultMaterial'] === undefined) {

                    cache['DefaultMaterial'] = new MeshStandardMaterial({
                        color: 0xFFFFFF,
                        emissive: 0x000000,
                        metalness: 1,
                        roughness: 1,
                        transparent: false,
                        depthTest: true,
                        side: FrontSide
                    });

                }

                return cache['DefaultMaterial'];

            }

            function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {

                // Add unknown glTF extensions to an object's userData.

                for (const name in objectDef.extensions) {

                    if (knownExtensions[name] === undefined) {

                        object.userData.gltfExtensions = object.userData.gltfExtensions || {};
                        object.userData.gltfExtensions[name] = objectDef.extensions[name];

                    }

                }

            }

            /**
             * @param {Object3D|Material|BufferGeometry} object
             * @param {GLTF.definition} gltfDef
             */
            function assignExtrasToUserData(object, gltfDef) {

                if (gltfDef.extras !== undefined) {

                    if (typeof gltfDef.extras === 'object') {

                        Object.assign(object.userData, gltfDef.extras);

                    } else {

                        console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);

                    }

                }

            }

            /**
             * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
             *
             * @param {BufferGeometry} geometry
             * @param {Array<GLTF.Target>} targets
             * @param {GLTFParser} parser
             * @return {Promise<BufferGeometry>}
             */
            function addMorphTargets(geometry, targets, parser) {

                let hasMorphPosition = false;
                let hasMorphNormal = false;
                let hasMorphColor = false;

                for (let i = 0, il = targets.length; i < il; i++) {

                    const target = targets[i];

                    if (target.POSITION !== undefined) hasMorphPosition = true;
                    if (target.NORMAL !== undefined) hasMorphNormal = true;
                    if (target.COLOR_0 !== undefined) hasMorphColor = true;

                    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;

                }

                if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);

                const pendingPositionAccessors = [];
                const pendingNormalAccessors = [];
                const pendingColorAccessors = [];

                for (let i = 0, il = targets.length; i < il; i++) {

                    const target = targets[i];

                    if (hasMorphPosition) {

                        const pendingAccessor = target.POSITION !== undefined
                            ? parser.getDependency('accessor', target.POSITION)
                            : geometry.attributes.position;

                        pendingPositionAccessors.push(pendingAccessor);

                    }

                    if (hasMorphNormal) {

                        const pendingAccessor = target.NORMAL !== undefined
                            ? parser.getDependency('accessor', target.NORMAL)
                            : geometry.attributes.normal;

                        pendingNormalAccessors.push(pendingAccessor);

                    }

                    if (hasMorphColor) {

                        const pendingAccessor = target.COLOR_0 !== undefined
                            ? parser.getDependency('accessor', target.COLOR_0)
                            : geometry.attributes.color;

                        pendingColorAccessors.push(pendingAccessor);

                    }

                }

                return Promise.all([
                    Promise.all(pendingPositionAccessors),
                    Promise.all(pendingNormalAccessors),
                    Promise.all(pendingColorAccessors)
                ]).then(function (accessors) {

                    const morphPositions = accessors[0];
                    const morphNormals = accessors[1];
                    const morphColors = accessors[2];

                    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
                    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
                    if (hasMorphColor) geometry.morphAttributes.color = morphColors;
                    geometry.morphTargetsRelative = true;

                    return geometry;

                });

            }

            /**
             * @param {Mesh} mesh
             * @param {GLTF.Mesh} meshDef
             */
            function updateMorphTargets(mesh, meshDef) {

                mesh.updateMorphTargets();

                if (meshDef.weights !== undefined) {

                    for (let i = 0, il = meshDef.weights.length; i < il; i++) {

                        mesh.morphTargetInfluences[i] = meshDef.weights[i];

                    }

                }

                // .extras has user-defined data, so check that .extras.targetNames is an array.
                if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {

                    const targetNames = meshDef.extras.targetNames;

                    if (mesh.morphTargetInfluences.length === targetNames.length) {

                        mesh.morphTargetDictionary = {};

                        for (let i = 0, il = targetNames.length; i < il; i++) {

                            mesh.morphTargetDictionary[targetNames[i]] = i;

                        }

                    } else {

                        console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');

                    }

                }

            }

            function createPrimitiveKey(primitiveDef) {

                const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
                let geometryKey;

                if (dracoExtension) {

                    geometryKey = 'draco:' + dracoExtension.bufferView
                        + ':' + dracoExtension.indices
                        + ':' + createAttributesKey(dracoExtension.attributes);

                } else {

                    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;

                }

                return geometryKey;

            }

            function createAttributesKey(attributes) {

                let attributesKey = '';

                const keys = Object.keys(attributes).sort();

                for (let i = 0, il = keys.length; i < il; i++) {

                    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';

                }

                return attributesKey;

            }

            function getNormalizedComponentScale(constructor) {

                // Reference:
                // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

                switch (constructor) {

                    case Int8Array:
                        return 1 / 127;

                    case Uint8Array:
                        return 1 / 255;

                    case Int16Array:
                        return 1 / 32767;

                    case Uint16Array:
                        return 1 / 65535;

                    default:
                        throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');

                }

            }

            function getImageURIMimeType(uri) {

                if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0) return 'image/jpeg';
                if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0) return 'image/webp';

                return 'image/png';

            }

            /* GLTF PARSER */

            class GLTFParser {

                constructor(json = {}, options = {}) {

                    this.json = json;
                    this.extensions = {};
                    this.plugins = {};
                    this.options = options;

                    // loader object cache
                    this.cache = new GLTFRegistry();

                    // associations between Three.js objects and glTF elements
                    this.associations = new Map();

                    // BufferGeometry caching
                    this.primitiveCache = {};

                    // Object3D instance caches
                    this.meshCache = { refs: {}, uses: {} };
                    this.cameraCache = { refs: {}, uses: {} };
                    this.lightCache = { refs: {}, uses: {} };

                    this.sourceCache = {};
                    this.textureCache = {};

                    // Track node names, to ensure no duplicates
                    this.nodeNamesUsed = {};

                    // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
                    // expensive work of uploading a texture to the GPU off the main thread.

                    let isSafari = false;
                    let isFirefox = false;
                    let firefoxVersion = - 1;

                    if (typeof navigator !== 'undefined') {

                        isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;
                        isFirefox = navigator.userAgent.indexOf('Firefox') > - 1;
                        firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : - 1;

                    }

                    if (typeof createImageBitmap === 'undefined' || isSafari || (isFirefox && firefoxVersion < 98)) {

                        this.textureLoader = new TextureLoader(this.options.manager);

                    } else {

                        this.textureLoader = new ImageBitmapLoader(this.options.manager);

                    }

                    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
                    this.textureLoader.setRequestHeader(this.options.requestHeader);

                    this.fileLoader = new FileLoader(this.options.manager);
                    this.fileLoader.setResponseType('arraybuffer');

                    if (this.options.crossOrigin === 'use-credentials') {

                        this.fileLoader.setWithCredentials(true);

                    }

                }

                setExtensions(extensions) {

                    this.extensions = extensions;

                }

                setPlugins(plugins) {

                    this.plugins = plugins;

                }

                parse(onLoad, onError) {

                    const parser = this;
                    const json = this.json;
                    const extensions = this.extensions;

                    // Clear the loader cache
                    this.cache.removeAll();

                    // Mark the special nodes/meshes in json for efficient parse
                    this._invokeAll(function (ext) {

                        return ext._markDefs && ext._markDefs();

                    });

                    Promise.all(this._invokeAll(function (ext) {

                        return ext.beforeRoot && ext.beforeRoot();

                    })).then(function () {

                        return Promise.all([

                            parser.getDependencies('scene'),
                            parser.getDependencies('animation'),
                            parser.getDependencies('camera'),

                        ]);

                    }).then(function (dependencies) {

                        const result = {
                            scene: dependencies[0][json.scene || 0],
                            scenes: dependencies[0],
                            animations: dependencies[1],
                            cameras: dependencies[2],
                            asset: json.asset,
                            parser: parser,
                            userData: {}
                        };

                        addUnknownExtensionsToUserData(extensions, result, json);

                        assignExtrasToUserData(result, json);

                        Promise.all(parser._invokeAll(function (ext) {

                            return ext.afterRoot && ext.afterRoot(result);

                        })).then(function () {

                            onLoad(result);

                        });

                    }).catch(onError);

                }

                /**
                 * Marks the special nodes/meshes in json for efficient parse.
                 */
                _markDefs() {

                    const nodeDefs = this.json.nodes || [];
                    const skinDefs = this.json.skins || [];
                    const meshDefs = this.json.meshes || [];

                    // Nothing in the node definition indicates whether it is a Bone or an
                    // Object3D. Use the skins' joint references to mark bones.
                    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {

                        const joints = skinDefs[skinIndex].joints;

                        for (let i = 0, il = joints.length; i < il; i++) {

                            nodeDefs[joints[i]].isBone = true;

                        }

                    }

                    // Iterate over all nodes, marking references to shared resources,
                    // as well as skeleton joints.
                    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {

                        const nodeDef = nodeDefs[nodeIndex];

                        if (nodeDef.mesh !== undefined) {

                            this._addNodeRef(this.meshCache, nodeDef.mesh);

                            // Nothing in the mesh definition indicates whether it is
                            // a SkinnedMesh or Mesh. Use the node's mesh reference
                            // to mark SkinnedMesh if node has skin.
                            if (nodeDef.skin !== undefined) {

                                meshDefs[nodeDef.mesh].isSkinnedMesh = true;

                            }

                        }

                        if (nodeDef.camera !== undefined) {

                            this._addNodeRef(this.cameraCache, nodeDef.camera);

                        }

                    }

                }

                /**
                 * Counts references to shared node / Object3D resources. These resources
                 * can be reused, or "instantiated", at multiple nodes in the scene
                 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
                 * be marked. Non-scenegraph resources (like Materials, Geometries, and
                 * Textures) can be reused directly and are not marked here.
                 *
                 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
                 */
                _addNodeRef(cache, index) {

                    if (index === undefined) return;

                    if (cache.refs[index] === undefined) {

                        cache.refs[index] = cache.uses[index] = 0;

                    }

                    cache.refs[index]++;

                }

                /** Returns a reference to a shared resource, cloning it if necessary. */
                _getNodeRef(cache, index, object) {

                    if (cache.refs[index] <= 1) return object;

                    const ref = object.clone();

                    // Propagates mappings to the cloned object, prevents mappings on the
                    // original object from being lost.
                    const updateMappings = (original, clone) => {

                        const mappings = this.associations.get(original);
                        if (mappings != null) {

                            this.associations.set(clone, mappings);

                        }

                        for (const [i, child] of original.children.entries()) {

                            updateMappings(child, clone.children[i]);

                        }

                    };

                    updateMappings(object, ref);

                    ref.name += '_instance_' + (cache.uses[index]++);

                    return ref;

                }

                _invokeOne(func) {

                    const extensions = Object.values(this.plugins);
                    extensions.push(this);

                    for (let i = 0; i < extensions.length; i++) {

                        const result = func(extensions[i]);

                        if (result) return result;

                    }

                    return null;

                }

                _invokeAll(func) {

                    const extensions = Object.values(this.plugins);
                    extensions.unshift(this);

                    const pending = [];

                    for (let i = 0; i < extensions.length; i++) {

                        const result = func(extensions[i]);

                        if (result) pending.push(result);

                    }

                    return pending;

                }

                /**
                 * Requests the specified dependency asynchronously, with caching.
                 * @param {string} type
                 * @param {number} index
                 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
                 */
                getDependency(type, index) {

                    const cacheKey = type + ':' + index;
                    let dependency = this.cache.get(cacheKey);

                    if (!dependency) {

                        switch (type) {

                            case 'scene':
                                dependency = this.loadScene(index);
                                break;

                            case 'node':
                                dependency = this.loadNode(index);
                                break;

                            case 'mesh':
                                dependency = this._invokeOne(function (ext) {

                                    return ext.loadMesh && ext.loadMesh(index);

                                });
                                break;

                            case 'accessor':
                                dependency = this.loadAccessor(index);
                                break;

                            case 'bufferView':
                                dependency = this._invokeOne(function (ext) {

                                    return ext.loadBufferView && ext.loadBufferView(index);

                                });
                                break;

                            case 'buffer':
                                dependency = this.loadBuffer(index);
                                break;

                            case 'material':
                                dependency = this._invokeOne(function (ext) {

                                    return ext.loadMaterial && ext.loadMaterial(index);

                                });
                                break;

                            case 'texture':
                                dependency = this._invokeOne(function (ext) {

                                    return ext.loadTexture && ext.loadTexture(index);

                                });
                                break;

                            case 'skin':
                                dependency = this.loadSkin(index);
                                break;

                            case 'animation':
                                dependency = this._invokeOne(function (ext) {

                                    return ext.loadAnimation && ext.loadAnimation(index);

                                });
                                break;

                            case 'camera':
                                dependency = this.loadCamera(index);
                                break;

                            default:
                                dependency = this._invokeOne(function (ext) {

                                    return ext != this && ext.getDependency && ext.getDependency(type, index);

                                });

                                if (!dependency) {

                                    throw new Error('Unknown type: ' + type);

                                }

                                break;

                        }

                        this.cache.add(cacheKey, dependency);

                    }

                    return dependency;

                }

                /**
                 * Requests all dependencies of the specified type asynchronously, with caching.
                 * @param {string} type
                 * @return {Promise<Array<Object>>}
                 */
                getDependencies(type) {

                    let dependencies = this.cache.get(type);

                    if (!dependencies) {

                        const parser = this;
                        const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];

                        dependencies = Promise.all(defs.map(function (def, index) {

                            return parser.getDependency(type, index);

                        }));

                        this.cache.add(type, dependencies);

                    }

                    return dependencies;

                }

                /**
                 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
                 * @param {number} bufferIndex
                 * @return {Promise<ArrayBuffer>}
                 */
                loadBuffer(bufferIndex) {

                    const bufferDef = this.json.buffers[bufferIndex];
                    const loader = this.fileLoader;

                    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {

                        throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');

                    }

                    // If present, GLB container is required to be the first buffer.
                    if (bufferDef.uri === undefined && bufferIndex === 0) {

                        return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);

                    }

                    const options = this.options;

                    return new Promise(function (resolve, reject) {

                        loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {

                            reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));

                        });

                    });

                }

                /**
                 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
                 * @param {number} bufferViewIndex
                 * @return {Promise<ArrayBuffer>}
                 */
                loadBufferView(bufferViewIndex) {

                    const bufferViewDef = this.json.bufferViews[bufferViewIndex];

                    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {

                        const byteLength = bufferViewDef.byteLength || 0;
                        const byteOffset = bufferViewDef.byteOffset || 0;
                        return buffer.slice(byteOffset, byteOffset + byteLength);

                    });

                }

                /**
                 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
                 * @param {number} accessorIndex
                 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
                 */
                loadAccessor(accessorIndex) {

                    const parser = this;
                    const json = this.json;

                    const accessorDef = this.json.accessors[accessorIndex];

                    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {

                        const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
                        const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
                        const normalized = accessorDef.normalized === true;

                        const array = new TypedArray(accessorDef.count * itemSize);
                        return Promise.resolve(new BufferAttribute(array, itemSize, normalized));

                    }

                    const pendingBufferViews = [];

                    if (accessorDef.bufferView !== undefined) {

                        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));

                    } else {

                        pendingBufferViews.push(null);

                    }

                    if (accessorDef.sparse !== undefined) {

                        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));
                        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));

                    }

                    return Promise.all(pendingBufferViews).then(function (bufferViews) {

                        const bufferView = bufferViews[0];

                        const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
                        const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];

                        // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
                        const elementBytes = TypedArray.BYTES_PER_ELEMENT;
                        const itemBytes = elementBytes * itemSize;
                        const byteOffset = accessorDef.byteOffset || 0;
                        const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;
                        const normalized = accessorDef.normalized === true;
                        let array, bufferAttribute;

                        // The buffer is not interleaved if the stride is the item size in bytes.
                        if (byteStride && byteStride !== itemBytes) {

                            // Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
                            // This makes sure that IBA.count reflects accessor.count properly
                            const ibSlice = Math.floor(byteOffset / byteStride);
                            const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
                            let ib = parser.cache.get(ibCacheKey);

                            if (!ib) {

                                array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);

                                // Integer parameters to IB/IBA are in array elements, not bytes.
                                ib = new InterleavedBuffer(array, byteStride / elementBytes);

                                parser.cache.add(ibCacheKey, ib);

                            }

                            bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, (byteOffset % byteStride) / elementBytes, normalized);

                        } else {

                            if (bufferView === null) {

                                array = new TypedArray(accessorDef.count * itemSize);

                            } else {

                                array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);

                            }

                            bufferAttribute = new BufferAttribute(array, itemSize, normalized);

                        }

                        // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
                        if (accessorDef.sparse !== undefined) {

                            const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
                            const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];

                            const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
                            const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

                            const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
                            const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);

                            if (bufferView !== null) {

                                // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
                                bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);

                            }

                            for (let i = 0, il = sparseIndices.length; i < il; i++) {

                                const index = sparseIndices[i];

                                bufferAttribute.setX(index, sparseValues[i * itemSize]);
                                if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
                                if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
                                if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
                                if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');

                            }

                        }

                        return bufferAttribute;

                    });

                }

                /**
                 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
                 * @param {number} textureIndex
                 * @return {Promise<THREE.Texture|null>}
                 */
                loadTexture(textureIndex) {

                    const json = this.json;
                    const options = this.options;
                    const textureDef = json.textures[textureIndex];
                    const sourceIndex = textureDef.source;
                    const sourceDef = json.images[sourceIndex];

                    let loader = this.textureLoader;

                    if (sourceDef.uri) {

                        const handler = options.manager.getHandler(sourceDef.uri);
                        if (handler !== null) loader = handler;

                    }

                    return this.loadTextureImage(textureIndex, sourceIndex, loader);

                }

                loadTextureImage(textureIndex, sourceIndex, loader) {

                    const parser = this;
                    const json = this.json;

                    const textureDef = json.textures[textureIndex];
                    const sourceDef = json.images[sourceIndex];

                    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ':' + textureDef.sampler;

                    if (this.textureCache[cacheKey]) {

                        // See https://github.com/mrdoob/three.js/issues/21559.
                        return this.textureCache[cacheKey];

                    }

                    const promise = this.loadImageSource(sourceIndex, loader).then(function (texture) {

                        texture.flipY = false;

                        texture.name = textureDef.name || sourceDef.name || '';

                        const samplers = json.samplers || {};
                        const sampler = samplers[textureDef.sampler] || {};

                        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
                        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
                        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
                        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;

                        parser.associations.set(texture, { textures: textureIndex });

                        return texture;

                    }).catch(function () {

                        return null;

                    });

                    this.textureCache[cacheKey] = promise;

                    return promise;

                }

                loadImageSource(sourceIndex, loader) {

                    const parser = this;
                    const json = this.json;
                    const options = this.options;

                    if (this.sourceCache[sourceIndex] !== undefined) {

                        return this.sourceCache[sourceIndex].then((texture) => texture.clone());

                    }

                    const sourceDef = json.images[sourceIndex];

                    const URL = self.URL || self.webkitURL;

                    let sourceURI = sourceDef.uri || '';
                    let isObjectURL = false;

                    if (sourceDef.bufferView !== undefined) {

                        // Load binary image data from bufferView, if provided.

                        sourceURI = parser.getDependency('bufferView', sourceDef.bufferView).then(function (bufferView) {

                            isObjectURL = true;
                            const blob = new Blob([bufferView], { type: sourceDef.mimeType });
                            sourceURI = URL.createObjectURL(blob);
                            return sourceURI;

                        });

                    } else if (sourceDef.uri === undefined) {

                        throw new Error('THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView');

                    }

                    const promise = Promise.resolve(sourceURI).then(function (sourceURI) {

                        return new Promise(function (resolve, reject) {

                            let onLoad = resolve;

                            if (loader.isImageBitmapLoader === true) {

                                onLoad = function (imageBitmap) {

                                    const texture = new Texture(imageBitmap);
                                    texture.needsUpdate = true;

                                    resolve(texture);

                                };

                            }

                            loader.load(LoaderUtils.resolveURL(sourceURI, options.path), onLoad, undefined, reject);

                        });

                    }).then(function (texture) {

                        // Clean up resources and configure Texture.

                        if (isObjectURL === true) {

                            URL.revokeObjectURL(sourceURI);

                        }

                        texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);

                        return texture;

                    }).catch(function (error) {

                        console.error('THREE.GLTFLoader: Couldn\'t load texture', sourceURI);
                        throw error;

                    });

                    this.sourceCache[sourceIndex] = promise;
                    return promise;

                }

                /**
                 * Asynchronously assigns a texture to the given material parameters.
                 * @param {Object} materialParams
                 * @param {string} mapName
                 * @param {Object} mapDef
                 * @return {Promise<Texture>}
                 */
                assignTexture(materialParams, mapName, mapDef, encoding) {

                    const parser = this;

                    return this.getDependency('texture', mapDef.index).then(function (texture) {

                        if (!texture) return null;

                        // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
                        // However, we will copy UV set 0 to UV set 1 on demand for aoMap
                        if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {

                            console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');

                        }

                        if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {

                            const transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;

                            if (transform) {

                                const gltfReference = parser.associations.get(texture);
                                texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
                                parser.associations.set(texture, gltfReference);

                            }

                        }

                        if (encoding !== undefined) {

                            texture.encoding = encoding;

                        }

                        materialParams[mapName] = texture;

                        return texture;

                    });

                }

                /**
                 * Assigns final material to a Mesh, Line, or Points instance. The instance
                 * already has a material (generated from the glTF material options alone)
                 * but reuse of the same glTF material may require multiple threejs materials
                 * to accommodate different primitive types, defines, etc. New materials will
                 * be created if necessary, and reused from a cache.
                 * @param  {Object3D} mesh Mesh, Line, or Points instance.
                 */
                assignFinalMaterial(mesh) {

                    const geometry = mesh.geometry;
                    let material = mesh.material;

                    const useDerivativeTangents = geometry.attributes.tangent === undefined;
                    const useVertexColors = geometry.attributes.color !== undefined;
                    const useFlatShading = geometry.attributes.normal === undefined;

                    if (mesh.isPoints) {

                        const cacheKey = 'PointsMaterial:' + material.uuid;

                        let pointsMaterial = this.cache.get(cacheKey);

                        if (!pointsMaterial) {

                            pointsMaterial = new PointsMaterial();
                            Material.prototype.copy.call(pointsMaterial, material);
                            pointsMaterial.color.copy(material.color);
                            pointsMaterial.map = material.map;
                            pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

                            this.cache.add(cacheKey, pointsMaterial);

                        }

                        material = pointsMaterial;

                    } else if (mesh.isLine) {

                        const cacheKey = 'LineBasicMaterial:' + material.uuid;

                        let lineMaterial = this.cache.get(cacheKey);

                        if (!lineMaterial) {

                            lineMaterial = new LineBasicMaterial();
                            Material.prototype.copy.call(lineMaterial, material);
                            lineMaterial.color.copy(material.color);

                            this.cache.add(cacheKey, lineMaterial);

                        }

                        material = lineMaterial;

                    }

                    // Clone the material if it will be modified
                    if (useDerivativeTangents || useVertexColors || useFlatShading) {

                        let cacheKey = 'ClonedMaterial:' + material.uuid + ':';

                        if (useDerivativeTangents) cacheKey += 'derivative-tangents:';
                        if (useVertexColors) cacheKey += 'vertex-colors:';
                        if (useFlatShading) cacheKey += 'flat-shading:';

                        let cachedMaterial = this.cache.get(cacheKey);

                        if (!cachedMaterial) {

                            cachedMaterial = material.clone();

                            if (useVertexColors) cachedMaterial.vertexColors = true;
                            if (useFlatShading) cachedMaterial.flatShading = true;

                            if (useDerivativeTangents) {

                                // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
                                if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= - 1;
                                if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= - 1;

                            }

                            this.cache.add(cacheKey, cachedMaterial);

                            this.associations.set(cachedMaterial, this.associations.get(material));

                        }

                        material = cachedMaterial;

                    }

                    // workarounds for mesh and geometry

                    if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {

                        geometry.setAttribute('uv2', geometry.attributes.uv);

                    }

                    mesh.material = material;

                }

                getMaterialType( /* materialIndex */) {

                    return MeshStandardMaterial;

                }

                /**
                 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
                 * @param {number} materialIndex
                 * @return {Promise<Material>}
                 */
                loadMaterial(materialIndex) {

                    const parser = this;
                    const json = this.json;
                    const extensions = this.extensions;
                    const materialDef = json.materials[materialIndex];

                    let materialType;
                    const materialParams = {};
                    const materialExtensions = materialDef.extensions || {};

                    const pending = [];

                    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {

                        const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
                        materialType = kmuExtension.getMaterialType();
                        pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));

                    } else {

                        // Specification:
                        // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

                        const metallicRoughness = materialDef.pbrMetallicRoughness || {};

                        materialParams.color = new Color(1.0, 1.0, 1.0);
                        materialParams.opacity = 1.0;

                        if (Array.isArray(metallicRoughness.baseColorFactor)) {

                            const array = metallicRoughness.baseColorFactor;

                            materialParams.color.fromArray(array);
                            materialParams.opacity = array[3];

                        }

                        if (metallicRoughness.baseColorTexture !== undefined) {

                            pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, sRGBEncoding));

                        }

                        materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
                        materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

                        if (metallicRoughness.metallicRoughnessTexture !== undefined) {

                            pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));
                            pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));

                        }

                        materialType = this._invokeOne(function (ext) {

                            return ext.getMaterialType && ext.getMaterialType(materialIndex);

                        });

                        pending.push(Promise.all(this._invokeAll(function (ext) {

                            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);

                        })));

                    }

                    if (materialDef.doubleSided === true) {

                        materialParams.side = DoubleSide;

                    }

                    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

                    if (alphaMode === ALPHA_MODES.BLEND) {

                        materialParams.transparent = true;

                        // See: https://github.com/mrdoob/three.js/issues/17706
                        materialParams.depthWrite = false;

                    } else {

                        materialParams.transparent = false;

                        if (alphaMode === ALPHA_MODES.MASK) {

                            materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

                        }

                    }

                    if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {

                        pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));

                        materialParams.normalScale = new Vector2(1, 1);

                        if (materialDef.normalTexture.scale !== undefined) {

                            const scale = materialDef.normalTexture.scale;

                            materialParams.normalScale.set(scale, scale);

                        }

                    }

                    if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {

                        pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));

                        if (materialDef.occlusionTexture.strength !== undefined) {

                            materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

                        }

                    }

                    if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {

                        materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);

                    }

                    if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {

                        pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture, sRGBEncoding));

                    }

                    return Promise.all(pending).then(function () {

                        const material = new materialType(materialParams);

                        if (materialDef.name) material.name = materialDef.name;

                        assignExtrasToUserData(material, materialDef);

                        parser.associations.set(material, { materials: materialIndex });

                        if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);

                        return material;

                    });

                }

                /** When Object3D instances are targeted by animation, they need unique names. */
                createUniqueName(originalName) {

                    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '');

                    let name = sanitizedName;

                    for (let i = 1; this.nodeNamesUsed[name]; ++i) {

                        name = sanitizedName + '_' + i;

                    }

                    this.nodeNamesUsed[name] = true;

                    return name;

                }

                /**
                 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
                 *
                 * Creates BufferGeometries from primitives.
                 *
                 * @param {Array<GLTF.Primitive>} primitives
                 * @return {Promise<Array<BufferGeometry>>}
                 */
                loadGeometries(primitives) {

                    const parser = this;
                    const extensions = this.extensions;
                    const cache = this.primitiveCache;

                    function createDracoPrimitive(primitive) {

                        return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]
                            .decodePrimitive(primitive, parser)
                            .then(function (geometry) {

                                return addPrimitiveAttributes(geometry, primitive, parser);

                            });

                    }

                    const pending = [];

                    for (let i = 0, il = primitives.length; i < il; i++) {

                        const primitive = primitives[i];
                        const cacheKey = createPrimitiveKey(primitive);

                        // See if we've already created this geometry
                        const cached = cache[cacheKey];

                        if (cached) {

                            // Use the cached geometry if it exists
                            pending.push(cached.promise);

                        } else {

                            let geometryPromise;

                            if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {

                                // Use DRACO geometry if available
                                geometryPromise = createDracoPrimitive(primitive);

                            } else {

                                // Otherwise create a new geometry
                                geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);

                            }

                            // Cache this geometry
                            cache[cacheKey] = { primitive: primitive, promise: geometryPromise };

                            pending.push(geometryPromise);

                        }

                    }

                    return Promise.all(pending);

                }

                /**
                 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
                 * @param {number} meshIndex
                 * @return {Promise<Group|Mesh|SkinnedMesh>}
                 */
                loadMesh(meshIndex) {

                    const parser = this;
                    const json = this.json;
                    const extensions = this.extensions;

                    const meshDef = json.meshes[meshIndex];
                    const primitives = meshDef.primitives;

                    const pending = [];

                    for (let i = 0, il = primitives.length; i < il; i++) {

                        const material = primitives[i].material === undefined
                            ? createDefaultMaterial(this.cache)
                            : this.getDependency('material', primitives[i].material);

                        pending.push(material);

                    }

                    pending.push(parser.loadGeometries(primitives));

                    return Promise.all(pending).then(function (results) {

                        const materials = results.slice(0, results.length - 1);
                        const geometries = results[results.length - 1];

                        const meshes = [];

                        for (let i = 0, il = geometries.length; i < il; i++) {

                            const geometry = geometries[i];
                            const primitive = primitives[i];

                            // 1. create Mesh

                            let mesh;

                            const material = materials[i];

                            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
                                primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
                                primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
                                primitive.mode === undefined) {

                                // .isSkinnedMesh isn't in glTF spec. See ._markDefs()
                                mesh = meshDef.isSkinnedMesh === true
                                    ? new SkinnedMesh(geometry, material)
                                    : new Mesh(geometry, material);

                                if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {

                                    // we normalize floating point skin weight array to fix malformed assets (see #15319)
                                    // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
                                    mesh.normalizeSkinWeights();

                                }

                                if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {

                                    mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);

                                } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {

                                    mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);

                                }

                            } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {

                                mesh = new LineSegments(geometry, material);

                            } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {

                                mesh = new Line(geometry, material);

                            } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {

                                mesh = new LineLoop(geometry, material);

                            } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {

                                mesh = new Points(geometry, material);

                            } else {

                                throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);

                            }

                            if (Object.keys(mesh.geometry.morphAttributes).length > 0) {

                                updateMorphTargets(mesh, meshDef);

                            }

                            mesh.name = parser.createUniqueName(meshDef.name || ('mesh_' + meshIndex));

                            assignExtrasToUserData(mesh, meshDef);

                            if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);

                            parser.assignFinalMaterial(mesh);

                            meshes.push(mesh);

                        }

                        for (let i = 0, il = meshes.length; i < il; i++) {

                            parser.associations.set(meshes[i], {
                                meshes: meshIndex,
                                primitives: i
                            });

                        }

                        if (meshes.length === 1) {

                            return meshes[0];

                        }

                        const group = new Group();

                        parser.associations.set(group, { meshes: meshIndex });

                        for (let i = 0, il = meshes.length; i < il; i++) {

                            group.add(meshes[i]);

                        }

                        return group;

                    });

                }

                /**
                 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
                 * @param {number} cameraIndex
                 * @return {Promise<THREE.Camera>}
                 */
                loadCamera(cameraIndex) {

                    let camera;
                    const cameraDef = this.json.cameras[cameraIndex];
                    const params = cameraDef[cameraDef.type];

                    if (!params) {

                        console.warn('THREE.GLTFLoader: Missing camera parameters.');
                        return;

                    }

                    if (cameraDef.type === 'perspective') {

                        camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);

                    } else if (cameraDef.type === 'orthographic') {

                        camera = new OrthographicCamera(- params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar);

                    }

                    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);

                    assignExtrasToUserData(camera, cameraDef);

                    return Promise.resolve(camera);

                }

                /**
                 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
                 * @param {number} skinIndex
                 * @return {Promise<Skeleton>}
                 */
                loadSkin(skinIndex) {

                    const skinDef = this.json.skins[skinIndex];

                    const pending = [];

                    for (let i = 0, il = skinDef.joints.length; i < il; i++) {

                        pending.push(this.getDependency('node', skinDef.joints[i]));

                    }

                    if (skinDef.inverseBindMatrices !== undefined) {

                        pending.push(this.getDependency('accessor', skinDef.inverseBindMatrices));

                    } else {

                        pending.push(null);

                    }

                    return Promise.all(pending).then(function (results) {

                        const inverseBindMatrices = results.pop();
                        const jointNodes = results;

                        const bones = [];
                        const boneInverses = [];

                        for (let i = 0, il = jointNodes.length; i < il; i++) {

                            const jointNode = jointNodes[i];

                            if (jointNode) {

                                bones.push(jointNode);

                                const mat = new Matrix4();

                                if (inverseBindMatrices !== null) {

                                    mat.fromArray(inverseBindMatrices.array, i * 16);

                                }

                                boneInverses.push(mat);

                            } else {

                                console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i]);

                            }

                        }

                        return new Skeleton(bones, boneInverses);

                    });

                }

                /**
                 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
                 * @param {number} animationIndex
                 * @return {Promise<AnimationClip>}
                 */
                loadAnimation(animationIndex) {

                    const json = this.json;

                    const animationDef = json.animations[animationIndex];

                    const pendingNodes = [];
                    const pendingInputAccessors = [];
                    const pendingOutputAccessors = [];
                    const pendingSamplers = [];
                    const pendingTargets = [];

                    for (let i = 0, il = animationDef.channels.length; i < il; i++) {

                        const channel = animationDef.channels[i];
                        const sampler = animationDef.samplers[channel.sampler];
                        const target = channel.target;
                        const name = target.node;
                        const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;
                        const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;

                        pendingNodes.push(this.getDependency('node', name));
                        pendingInputAccessors.push(this.getDependency('accessor', input));
                        pendingOutputAccessors.push(this.getDependency('accessor', output));
                        pendingSamplers.push(sampler);
                        pendingTargets.push(target);

                    }

                    return Promise.all([

                        Promise.all(pendingNodes),
                        Promise.all(pendingInputAccessors),
                        Promise.all(pendingOutputAccessors),
                        Promise.all(pendingSamplers),
                        Promise.all(pendingTargets)

                    ]).then(function (dependencies) {

                        const nodes = dependencies[0];
                        const inputAccessors = dependencies[1];
                        const outputAccessors = dependencies[2];
                        const samplers = dependencies[3];
                        const targets = dependencies[4];

                        const tracks = [];

                        for (let i = 0, il = nodes.length; i < il; i++) {

                            const node = nodes[i];
                            const inputAccessor = inputAccessors[i];
                            const outputAccessor = outputAccessors[i];
                            const sampler = samplers[i];
                            const target = targets[i];

                            if (node === undefined) continue;

                            node.updateMatrix();

                            let TypedKeyframeTrack;

                            switch (PATH_PROPERTIES[target.path]) {

                                case PATH_PROPERTIES.weights:

                                    TypedKeyframeTrack = NumberKeyframeTrack;
                                    break;

                                case PATH_PROPERTIES.rotation:

                                    TypedKeyframeTrack = QuaternionKeyframeTrack;
                                    break;

                                case PATH_PROPERTIES.position:
                                case PATH_PROPERTIES.scale:
                                default:

                                    TypedKeyframeTrack = VectorKeyframeTrack;
                                    break;

                            }

                            const targetName = node.name ? node.name : node.uuid;

                            const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;

                            const targetNames = [];

                            if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {

                                node.traverse(function (object) {

                                    if (object.morphTargetInfluences) {

                                        targetNames.push(object.name ? object.name : object.uuid);

                                    }

                                });

                            } else {

                                targetNames.push(targetName);

                            }

                            let outputArray = outputAccessor.array;

                            if (outputAccessor.normalized) {

                                const scale = getNormalizedComponentScale(outputArray.constructor);
                                const scaled = new Float32Array(outputArray.length);

                                for (let j = 0, jl = outputArray.length; j < jl; j++) {

                                    scaled[j] = outputArray[j] * scale;

                                }

                                outputArray = scaled;

                            }

                            for (let j = 0, jl = targetNames.length; j < jl; j++) {

                                const track = new TypedKeyframeTrack(
                                    targetNames[j] + '.' + PATH_PROPERTIES[target.path],
                                    inputAccessor.array,
                                    outputArray,
                                    interpolation
                                );

                                // Override interpolation with custom factory method.
                                if (sampler.interpolation === 'CUBICSPLINE') {

                                    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {

                                        // A CUBICSPLINE keyframe in glTF has three output values for each input value,
                                        // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
                                        // must be divided by three to get the interpolant's sampleSize argument.

                                        const interpolantType = (this instanceof QuaternionKeyframeTrack) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;

                                        return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);

                                    };

                                    // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
                                    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

                                }

                                tracks.push(track);

                            }

                        }

                        const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

                        return new AnimationClip(name, undefined, tracks);

                    });

                }

                createNodeMesh(nodeIndex) {

                    const json = this.json;
                    const parser = this;
                    const nodeDef = json.nodes[nodeIndex];

                    if (nodeDef.mesh === undefined) return null;

                    return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {

                        const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);

                        // if weights are provided on the node, override weights on the mesh.
                        if (nodeDef.weights !== undefined) {

                            node.traverse(function (o) {

                                if (!o.isMesh) return;

                                for (let i = 0, il = nodeDef.weights.length; i < il; i++) {

                                    o.morphTargetInfluences[i] = nodeDef.weights[i];

                                }

                            });

                        }

                        return node;

                    });

                }

                /**
                 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
                 * @param {number} nodeIndex
                 * @return {Promise<Object3D>}
                 */
                loadNode(nodeIndex) {

                    const json = this.json;
                    const extensions = this.extensions;
                    const parser = this;

                    const nodeDef = json.nodes[nodeIndex];

                    // reserve node's name before its dependencies, so the root has the intended name.
                    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : '';

                    return (function () {

                        const pending = [];

                        const meshPromise = parser._invokeOne(function (ext) {

                            return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);

                        });

                        if (meshPromise) {

                            pending.push(meshPromise);

                        }

                        if (nodeDef.camera !== undefined) {

                            pending.push(parser.getDependency('camera', nodeDef.camera).then(function (camera) {

                                return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);

                            }));

                        }

                        parser._invokeAll(function (ext) {

                            return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);

                        }).forEach(function (promise) {

                            pending.push(promise);

                        });

                        return Promise.all(pending);

                    }()).then(function (objects) {

                        let node;

                        // .isBone isn't in glTF spec. See ._markDefs
                        if (nodeDef.isBone === true) {

                            node = new Bone();

                        } else if (objects.length > 1) {

                            node = new Group();

                        } else if (objects.length === 1) {

                            node = objects[0];

                        } else {

                            node = new Object3D();

                        }

                        if (node !== objects[0]) {

                            for (let i = 0, il = objects.length; i < il; i++) {

                                node.add(objects[i]);

                            }

                        }

                        if (nodeDef.name) {

                            node.userData.name = nodeDef.name;
                            node.name = nodeName;

                        }

                        assignExtrasToUserData(node, nodeDef);

                        if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);

                        if (nodeDef.matrix !== undefined) {

                            const matrix = new Matrix4();
                            matrix.fromArray(nodeDef.matrix);
                            node.applyMatrix4(matrix);

                        } else {

                            if (nodeDef.translation !== undefined) {

                                node.position.fromArray(nodeDef.translation);

                            }

                            if (nodeDef.rotation !== undefined) {

                                node.quaternion.fromArray(nodeDef.rotation);

                            }

                            if (nodeDef.scale !== undefined) {

                                node.scale.fromArray(nodeDef.scale);

                            }

                        }

                        if (!parser.associations.has(node)) {

                            parser.associations.set(node, {});

                        }

                        parser.associations.get(node).nodes = nodeIndex;

                        return node;

                    });

                }

                /**
                 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
                 * @param {number} sceneIndex
                 * @return {Promise<Group>}
                 */
                loadScene(sceneIndex) {

                    const json = this.json;
                    const extensions = this.extensions;
                    const sceneDef = this.json.scenes[sceneIndex];
                    const parser = this;

                    // Loader returns Group, not Scene.
                    // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
                    const scene = new Group();
                    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);

                    assignExtrasToUserData(scene, sceneDef);

                    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);

                    const nodeIds = sceneDef.nodes || [];

                    const pending = [];

                    for (let i = 0, il = nodeIds.length; i < il; i++) {

                        pending.push(buildNodeHierarchy(nodeIds[i], scene, json, parser));

                    }

                    return Promise.all(pending).then(function () {

                        // Removes dangling associations, associations that reference a node that
                        // didn't make it into the scene.
                        const reduceAssociations = (node) => {

                            const reducedAssociations = new Map();

                            for (const [key, value] of parser.associations) {

                                if (key instanceof Material || key instanceof Texture) {

                                    reducedAssociations.set(key, value);

                                }

                            }

                            node.traverse((node) => {

                                const mappings = parser.associations.get(node);

                                if (mappings != null) {

                                    reducedAssociations.set(node, mappings);

                                }

                            });

                            return reducedAssociations;

                        };

                        parser.associations = reduceAssociations(scene);

                        return scene;

                    });

                }

            }

            function buildNodeHierarchy(nodeId, parentObject, json, parser) {

                const nodeDef = json.nodes[nodeId];

                return parser.getDependency('node', nodeId).then(function (node) {

                    if (nodeDef.skin === undefined) return node;

                    // build skeleton here as well

                    return parser.getDependency('skin', nodeDef.skin).then(function (skeleton) {

                        node.traverse(function (mesh) {

                            if (!mesh.isSkinnedMesh) return;

                            mesh.bind(skeleton, mesh.matrixWorld);

                        });

                        return node;

                    });

                }).then(function (node) {

                    // build node hierachy

                    parentObject.add(node);

                    const pending = [];

                    if (nodeDef.children) {

                        const children = nodeDef.children;

                        for (let i = 0, il = children.length; i < il; i++) {

                            const child = children[i];
                            pending.push(buildNodeHierarchy(child, node, json, parser));

                        }

                    }

                    return Promise.all(pending);

                });

            }

            /**
             * @param {BufferGeometry} geometry
             * @param {GLTF.Primitive} primitiveDef
             * @param {GLTFParser} parser
             */
            function computeBounds(geometry, primitiveDef, parser) {

                const attributes = primitiveDef.attributes;

                const box = new Box3();

                if (attributes.POSITION !== undefined) {

                    const accessor = parser.json.accessors[attributes.POSITION];

                    const min = accessor.min;
                    const max = accessor.max;

                    // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

                    if (min !== undefined && max !== undefined) {

                        box.set(
                            new Vector3(min[0], min[1], min[2]),
                            new Vector3(max[0], max[1], max[2])
                        );

                        if (accessor.normalized) {

                            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
                            box.min.multiplyScalar(boxScale);
                            box.max.multiplyScalar(boxScale);

                        }

                    } else {

                        console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');

                        return;

                    }

                } else {

                    return;

                }

                const targets = primitiveDef.targets;

                if (targets !== undefined) {

                    const maxDisplacement = new Vector3();
                    const vector = new Vector3();

                    for (let i = 0, il = targets.length; i < il; i++) {

                        const target = targets[i];

                        if (target.POSITION !== undefined) {

                            const accessor = parser.json.accessors[target.POSITION];
                            const min = accessor.min;
                            const max = accessor.max;

                            // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

                            if (min !== undefined && max !== undefined) {

                                // we need to get max of absolute components because target weight is [-1,1]
                                vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
                                vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
                                vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));


                                if (accessor.normalized) {

                                    const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
                                    vector.multiplyScalar(boxScale);

                                }

                                // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
                                // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
                                // are used to implement key-frame animations and as such only two are active at a time - this results in very large
                                // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
                                maxDisplacement.max(vector);

                            } else {

                                console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');

                            }

                        }

                    }

                    // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
                    box.expandByVector(maxDisplacement);

                }

                geometry.boundingBox = box;

                const sphere = new Sphere();

                box.getCenter(sphere.center);
                sphere.radius = box.min.distanceTo(box.max) / 2;

                geometry.boundingSphere = sphere;

            }

            /**
             * @param {BufferGeometry} geometry
             * @param {GLTF.Primitive} primitiveDef
             * @param {GLTFParser} parser
             * @return {Promise<BufferGeometry>}
             */
            function addPrimitiveAttributes(geometry, primitiveDef, parser) {

                const attributes = primitiveDef.attributes;

                const pending = [];

                function assignAttributeAccessor(accessorIndex, attributeName) {

                    return parser.getDependency('accessor', accessorIndex)
                        .then(function (accessor) {

                            geometry.setAttribute(attributeName, accessor);

                        });

                }

                for (const gltfAttributeName in attributes) {

                    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();

                    // Skip attributes already provided by e.g. Draco extension.
                    if (threeAttributeName in geometry.attributes) continue;

                    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));

                }

                if (primitiveDef.indices !== undefined && !geometry.index) {

                    const accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {

                        geometry.setIndex(accessor);

                    });

                    pending.push(accessor);

                }

                assignExtrasToUserData(geometry, primitiveDef);

                computeBounds(geometry, primitiveDef, parser);

                return Promise.all(pending).then(function () {

                    return primitiveDef.targets !== undefined
                        ? addMorphTargets(geometry, primitiveDef.targets, parser)
                        : geometry;

                });

            }

            /**
             * @param {BufferGeometry} geometry
             * @param {Number} drawMode
             * @return {BufferGeometry}
             */
            function toTrianglesDrawMode(geometry, drawMode) {

                let index = geometry.getIndex();

                // generate index if not present

                if (index === null) {

                    const indices = [];

                    const position = geometry.getAttribute('position');

                    if (position !== undefined) {

                        for (let i = 0; i < position.count; i++) {

                            indices.push(i);

                        }

                        geometry.setIndex(indices);
                        index = geometry.getIndex();

                    } else {

                        console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');
                        return geometry;

                    }

                }

                //

                const numberOfTriangles = index.count - 2;
                const newIndices = [];

                if (drawMode === TriangleFanDrawMode) {

                    // gl.TRIANGLE_FAN

                    for (let i = 1; i <= numberOfTriangles; i++) {

                        newIndices.push(index.getX(0));
                        newIndices.push(index.getX(i));
                        newIndices.push(index.getX(i + 1));

                    }

                } else {

                    // gl.TRIANGLE_STRIP

                    for (let i = 0; i < numberOfTriangles; i++) {

                        if (i % 2 === 0) {

                            newIndices.push(index.getX(i));
                            newIndices.push(index.getX(i + 1));
                            newIndices.push(index.getX(i + 2));


                        } else {

                            newIndices.push(index.getX(i + 2));
                            newIndices.push(index.getX(i + 1));
                            newIndices.push(index.getX(i));

                        }

                    }

                }

                if ((newIndices.length / 3) !== numberOfTriangles) {

                    console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');

                }

                // build final geometry

                const newGeometry = geometry.clone();
                newGeometry.setIndex(newIndices);

                return newGeometry;

            }

            function isObjEmpty(obj) {
                return (
                    obj === undefined ||
                    obj === "undefined" ||
                    obj == null ||
                    obj === "" ||
                    obj.length === 0 ||
                    (typeof obj === "object" && Object.keys(obj).length === 0)
                );
            };
            function isPhone() {
                return (navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))
            };
            new Vue({
                el: '#app',
                data() {
                    return {
                        camera: null,
                        width: document.documentElement.clientWidth || window.innerWidth,
                        height: document.documentElement.clientHeight || window.innerHeight,
                        canvasWidth: 0,
                        canvasHeight: 0,
                        actionShow: false,
                        deviceList: [], //设备列表
                        isCameraOpen: false, //摄像头是否打开
                        task: null, //任务
                        model: null, //模型
                        modelLoad: true, //模型加载中
                        deviceId: localStorage.getItem(`deviceId`) || 'user', //设备id
                        flipHorizontal: false, // 是否水平翻转
                        // three
                        scene: null,
                        threeCamera: null,
                        renderer: null,
                        geometry: null,
                        background: null,
                        mesh: null,
                        Object3D: null,
                        morphTarget: null,
                        // three
                        meshPopup: false,
                        meshIndex: 0,
                        meshListAll: [{
                            name: `敬过往祈新年`,
                            src: `https://dcdn.it120.cc/2022/12/14/cb57d900-8597-4c70-b34d-2966dc428bc7.png`,
                            srcX: `https://dcdn.it120.cc/2022/12/14/3f1e0c82-3455-4896-9ea3-d19541db52be.png`
                        }, {
                            "name": "彩色贴纸",
                            "src": "https://dcdn.it120.cc/2022/12/06/795dea0b-76e9-48b8-a162-20b29d2731a7.png"
                        },
                        {
                            "name": "3D面部贴纸",
                            "src": "https://dcdn.it120.cc/2022/12/09/770e9c62-2fb6-4899-8b3e-93437cbaddfb.png"
                        },

                        {
                            "name": "小可爱",
                            "src": "https://dcdn.it120.cc/2022/12/06/58158efb-6138-4df8-9986-bc0bdea4de08.png"
                        },
                        {
                            "name": "小雀斑",
                            "src": "https://dcdn.it120.cc/2022/12/06/ce3bf4bc-311f-49f4-82ff-96f9a045557e.png"
                        },
                        {
                            "name": "掘金",
                            "src": "https://dcdn.it120.cc/2022/12/07/6e3fb315-fbbd-4cba-8102-2744161cfb50.png"
                        },
                        {
                            "name": "大红唇+睫毛膏",
                            "src": "https://dcdn.it120.cc/2022/12/07/9a31a6ac-ac04-40df-b890-af64ca3ae33a.png"
                        },
                        {
                            "name": "眼影",
                            "src": "https://dcdn.it120.cc/2022/12/07/fb96a09a-0d58-4365-b3f8-57054168517c.png"
                        },
                        {
                            "name": "中国国旗",
                            "src": "https://dcdn.it120.cc/2022/12/07/dac52247-8c04-420f-84e6-26fc4b430b5e.png"
                        },
                        {
                            "name": "眼镜",
                            "src": "https://dcdn.it120.cc/2022/12/09/62fcfd9a-191e-4a9d-9c6a-b99e92ef7512.png"
                        },
                        {
                            "name": "猪头",
                            "type": "model",
                            "src": "https://dcdn.it120.cc/2022/12/07/e64174b8-a96c-4f36-9b70-9ed5c952f4df.png",
                            "model": "https://dcdn.it120.cc/2022/12/07/55607c9c-1aaa-494a-b332-6a5360933c4a.glb"
                        },
                        {
                            "name": "大象",
                            "type": "model",
                            "src": "https://dcdn.it120.cc/2022/12/07/208ccc82-94db-4aab-a431-c7531ec190a3.png",
                            "model": "https://dcdn.it120.cc/2022/12/07/4c4096b0-fd19-4a1b-886c-7b263c35dfe9.glb"
                        },
                        {
                            "name": "小狗",
                            "type": "model",
                            "src": "https://dcdn.it120.cc/2022/12/07/bb97bbff-3799-4a16-88f9-527495859e0d.png",
                            "model": "https://dcdn.it120.cc/2022/12/07/2204b6c9-e334-4e56-b056-2fe19ca7a578.glb"
                        },
                        {
                            "name": "猴子",
                            "type": "model",
                            "src": "https://dcdn.it120.cc/2022/12/07/38c7776f-8604-45fc-bc4e-60435bc03f6e.png",
                            "model": "https://dcdn.it120.cc/2022/12/07/92fbd0de-9d5f-449e-999f-709e7eb0cc63.glb"
                        },
                        {
                            "name": "爱心眼镜",
                            "calculateFun": "Heartglasses",
                            "type": "model",
                            "src": "https://dcdn.it120.cc/2022/12/07/e6fa3b86-863c-4d6e-844c-0e1cd03bf32c.png",
                            "model": "https://dcdn.it120.cc/2022/12/07/752de96c-bc3f-4fab-b73f-12626dad8977.glb"
                        },
                        {
                            "name": "防护眼镜(test)",
                            "calculateFun": "Heartglasses",
                            "type": "model",
                            "src": "https://dcdn.it120.cc/2022/12/13/cf78108d-3511-4c65-9502-3c92e7d4a312.png",
                            "model": "https://dcdn.it120.cc/2022/12/13/40e7af5b-97a5-45a1-8944-f172f6e04fa3.glb"
                        }],
                        meshList: [],
                        helpTextModel: ['0'],
                        tabsActive: 'stickers'
                    };
                },
                async mounted() {
                    if (isPhone()) {
                        this.flipHorizontal = true;
                    }
                    await this.getData();
                    this.$dialog.alert({
                        message: `
                        <div class="prompt-text">
                            <h5>AR面部贴纸</h5>
                            <ol>
                                <li>首次模型加载模型可能需要1-2分钟，请耐心等待</li>
                                <li>需要打开摄像头，（不会把您的摄像头信息上传到服务端）</li>
                                <li>打开摄像头后如发现摄像头是镜像，可点击“切换镜像”。</li>
                            </ol>
                        </div>`,
                        theme: 'round-button',
                        className: 'helpdialog',
                        confirmButtonText: '开始吧'
                    })
                        .then(() => {
                            this.cameraInit();
                            this.openCamera();
                        })
                },
                async beforeDestroy() {
                    this.isCameraOpen = false;
                    window.cancelAnimationFrame(this.task);
                    this.mesh && this.scene.remove(this.mesh);
                    this.geometry && this.scene.remove(this.geometry);
                    this.renderer && this.renderer.dispose();
                    this.threeCamera = null;
                    this.camera && await this.camera.stop();
                },
                methods: {
                    isEmpty(e) {
                        return isObjEmpty(e)
                    },
                    tabsChange() {
                        const tabsActive = this.tabsActive;
                        this.meshIndex = -1;
                        this.mesh && this.scene.remove(this.mesh);
                        this.Object3D && (this.Object3D.visible = false)
                        this.geometry && this.scene.remove(this.geometry);
                        if (tabsActive == "stickers") {
                            this.meshList = this.meshListAll.filter(e => e.type != "model");
                        };
                        if (tabsActive == "3Dmodel") {
                            this.meshList = this.meshListAll.filter(e => e.type === "model");
                        };
                    },
                    //获取数据
                    async getData() {
                        const toast = this.$toast.loading({
                            duration: 0, // 持续展示 toast
                            forbidClick: true,
                            message: '获取贴纸',
                        });
                        try {
                            // const url = "https://wangpeng1478.github.io/web/faceMesh/data.json";
                            // const response = await fetch(`${url}?s=${new Date().getDate()}_${new Date().getHours()}`).then(r => r.json());
                            // this.meshListAll = response;
                            this.tabsChange();
                        } catch (error) {
                            console.log('getData', error);
                        } finally {
                            toast.clear();
                        }
                    },
                    uploaderImage(file) {
                        const toast = this.$toast.loading({
                            duration: 0, // 持续展示 toast
                            forbidClick: true,
                            message: 'loading',
                        });
                        const url = window.URL && window.URL.createObjectURL(file);
                        if (file.type.includes('image/')) {
                            this.meshList.push({
                                src: url,
                                name: file.name
                            })
                            this.meshListAll.push({
                                src: url,
                                name: file.name
                            })
                            toast.clear();
                        } else {
                            toast.clear();
                            this.$toast('图片格式错误-' + file.type)
                        }
                        return false
                    },
                    uploaderGlb(file) {
                        const toast = this.$toast.loading({
                            duration: 0, // 持续展示 toast
                            forbidClick: true,
                            message: 'loading',
                        });
                        const url = window.URL && window.URL.createObjectURL(file);
                        if (file.name.includes('.glb')) {
                            this.meshListAll.push({
                                model: url,
                                type: "model",
                                name: file.name
                            })
                            this.meshList.push({
                                model: url,
                                type: "model",
                                name: file.name
                            })
                            toast.clear();
                        } else {
                            toast.clear();
                            this.$toast('格式错误-' + file.type)
                        }
                        return false
                    },
                    //创建3d场景
                    Create3dScene() {
                        let w = this.canvasWidth;
                        let h = this.canvasHeight;
                        let video = this.$refs.video;
                        let canvas = this.$refs.canvas;

                        const scene = new THREE.Scene()
                        // 根据你的需要，也可以把camera画面当作scene的背景
                        const backgroundTexture = new THREE.VideoTexture(video)
                        const background = new THREE.Mesh(
                            new THREE.PlaneGeometry(w, h),
                            new THREE.MeshBasicMaterial({
                                map: backgroundTexture
                            })
                        )
                        background.position.set(0, 0, -1000)
                        scene.add(background)

                        // 放置camera，这里选用的是正交相机(OrthographicCamera)
                        const camera = new THREE.OrthographicCamera(
                            w / -2,
                            w / 2,
                            h / 2,
                            h / -2,
                            0,
                            2000
                        )
                        camera.position.set(0, 0, 1000)
                        camera.lookAt(scene.position)

                        // 添加一些光照
                        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.3)
                        scene.add(hemiLight)
                        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7)
                        scene.add(ambientLight)
                        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7)
                        directionalLight.position.set(0.5, 0, 0.866)
                        scene.add(directionalLight)

                        // 创建渲染器
                        const renderer = new THREE.WebGLRenderer({
                            canvas,
                            alpha: true,
                            antialias: true
                        })
                        renderer.setPixelRatio(window.devicePixelRatio)
                        renderer.setSize(w, h)

                        this.scene = scene;
                        this.threeCamera = camera;
                        this.background = background;
                        this.renderer = renderer;
                        this.changeMesh();
                    },
                    //改变
                    changeMesh(meshIndex = 0) {
                        if (meshIndex === -1) return;
                        if (this.tabsActive == "stickers") {
                            const toast = this.$toast.loading({
                                duration: 0, // 持续展示 toast
                                forbidClick: true,
                                message: '加载贴图中',
                            });
                            try {
                                this.mesh && this.scene.remove(this.mesh);
                                this.geometry && this.scene.remove(this.geometry);

                                const geometry = new THREE.BufferGeometry()
                                geometry.setIndex(TRIANGULATION)
                                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(UVS.map((item, index) => index % 2 ? item : 1 - item), 2))
                                geometry.computeVertexNormals()
                                this.geometry = geometry;


                                const textureLoader = new THREE.TextureLoader();
                                const {src,srcX} = this.meshList[meshIndex];
                                textureLoader.load(this.flipHorizontal?src:srcX||src, texture => {
                                    texture.encoding = THREE.sRGBEncoding
                                    texture.anisotropy = 16
                                    const material = new THREE.MeshBasicMaterial({
                                        map: texture,
                                        transparent: true,
                                        color: new THREE.Color(0xffffff), //设置材质的颜色
                                        reflectivity: 0.5
                                    });
                                    const mesh = new THREE.Mesh(geometry, material)
                                    this.scene.add(mesh)
                                    this.mesh = mesh;
                                    this.meshIndex = meshIndex;
                                    this.meshPopup = false;
                                    toast.clear();
                                })
                            } catch (error) {
                                console.log(error);
                                toast.clear();
                                this.$toast('图片设置失败')
                            }
                        };
                        if (this.tabsActive == "3Dmodel") {
                            const toast = this.$toast.loading({
                                duration: 0, // 持续展示 toast
                                forbidClick: true,
                                message: '加载3D模型中',
                            });
                            try {

                                //模型地址
                                const modelUrl = this.meshList[meshIndex].model;
                                console.log('modelUrl', modelUrl);
                                const loader = new GLTFLoader();
                                const Object3D = new THREE.Object3D();
                                this.Object3D && this.scene.remove(this.Object3D);
                                Object3D.position.set(0, 0, 0)
                                loader.load(modelUrl, (gltf) => {
                                    const object = gltf.scene
                                    const box = new THREE.Box3().setFromObject(object)
                                    const size = box.getSize(new THREE.Vector3()).length()
                                    const center = box.getCenter(new THREE.Vector3())
                                    object.position.x += (object.position.x - center.x);
                                    object.position.y += (object.position.y - center.y + 1);
                                    object.position.z += (object.position.z - center.z - 15);
                                    Object3D.add(object)
                                    this.scene.add(Object3D)

                                    // 面部动作
                                    this.morphTarget = this.findMorphTarget(object)
                                    this.Object3D = Object3D;
                                    this.meshIndex = meshIndex;
                                    this.meshPopup = false;
                                    toast.clear();
                                    console.log('面部动作', this.morphTarget);
                                })
                            } catch (error) {
                                console.log(error);
                                toast.clear();
                                this.$toast('图片设置失败')
                            }
                        };
                    },
                    renderStickers(prediction) {
                        if (prediction) {
                            this.updateGeometry(prediction)
                        }
                        this.renderer.render(this.scene, this.threeCamera)
                    },
                    // 根据face mesh实时更新geometry
                    updateGeometry(prediction) {
                        let w = this.canvasWidth;
                        let h = this.canvasHeight;
                        const faceMesh = this.resolveMesh(prediction.scaledMesh, w, h)
                        const positionBuffer = faceMesh.reduce((acc, pos) => acc.concat(pos), [])
                        this.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positionBuffer, 3))
                        this.geometry.attributes.position.needsUpdate = true
                    },
                    //计算Matrix[通用]
                    track(object, prediction) {
                        try {
                            // position: 以眉心(midwayBetweenEyes)[168]作为位置基准
                            const position = prediction.midwayBetweenEyes[0]
                            // scale: 以最左侧(234)和最右侧(454)的距离作为缩放基准
                            const scale = this.getScale(prediction.scaledMesh, 234, 454)
                            // rotation: 以头顶(10)左脸颊(50)右脸颊(280)作为旋转基准
                            const rotation = this.getRotation(prediction.scaledMesh, 10, 50, 280)
                            object.position.set(...position)
                            object.scale.setScalar(scale / 20)
                            object.scale.x *= -1
                            object.rotation.setFromRotationMatrix(rotation)
                            object.rotation.y = -object.rotation.y
                            object.rotateZ(Math.PI)
                            object.rotateX(-Math.PI * .05)
                            if (this.morphTarget) {
                                // flipped
                                this.morphTarget['leftEye'] && this.morphTarget['leftEye'](1 - prediction.faceRig.eye.r)
                                this.morphTarget['rightEye'] && this.morphTarget['rightEye'](1 - prediction.faceRig.eye.l)
                                this.morphTarget['mouth'] && this.morphTarget['mouth'](prediction.faceRig.mouth.shape.A)
                            }
                        } catch (error) {
                            // console.log(error);
                        }
                    },
                    //计算Matrix[爱心眼镜]
                    trackHeartglasses(object, prediction) {
                        try {
                            const position = [168].map(idx => prediction.faceMesh[idx])[0]
                            // scale: 以最左侧(234)和最右侧(454)的距离作为缩放基准
                            const scale = this.getScale(prediction.scaledMesh, 234, 454)
                            // rotation: 以头顶(10)左脸颊(50)右脸颊(280)作为旋转基准
                            const rotation = this.getRotation(prediction.scaledMesh, 10, 50, 280)
                            object.position.set(...position)
                            object.scale.setScalar(scale / 17)
                            object.scale.x *= -1
                            object.rotation.setFromRotationMatrix(rotation)
                            object.rotation.y = -object.rotation.y
                            object.rotateZ(Math.PI)
                            object.rotateX(-Math.PI * .1)
                        } catch (error) {
                            console.log(error);
                        }
                    },
                    //面部动作
                    findMorphTarget(nodes, value) {
                        const morphTarget = {};
                        const traverse = (node) => {
                            if (node.type === 'Mesh' && node.morphTargetInfluences) {
                                const mesh = node;
                                Object.keys(mesh.morphTargetDictionary).forEach(key => {
                                    morphTarget[key] = (value) => {
                                        mesh.morphTargetInfluences[mesh.morphTargetDictionary[key]] = value
                                    }
                                })
                            }
                            node.children.forEach(traverse)
                        }
                        traverse(nodes)
                        return morphTarget
                    },
                    getScale(n, e = 0, t = 1) {
                        const pos1 = new THREE.Vector3(...n[e]);
                        const pos2 = new THREE.Vector3(...n[t]);
                        return pos1.distanceTo(pos2)
                    },
                    getRotation(n, e = 0, t = 1, s = 2) {
                        const pos1 = new THREE.Vector3(...n[e]);
                        const pos2 = new THREE.Vector3(...n[t]);
                        const pos3 = new THREE.Vector3(...n[s]);
                        const m4 = new THREE.Matrix4();
                        const axisX = pos2.clone().sub(pos3).normalize()
                        const axisY = pos2.clone().add(pos3).multiplyScalar(.5).sub(pos1).multiplyScalar(-1).normalize()
                        const axisZ = new THREE.Vector3().crossVectors(axisX, axisY).normalize();
                        return m4.makeBasis(axisX, axisY, axisZ).invert()
                    },
                    render3D(prediction) {
                        if (prediction) {
                            //对一些特殊的模型单独计算
                            const { calculateFun } = this.meshList[this.meshIndex] || {};
                            if (this.isEmpty(calculateFun)) {
                                //通用计算
                                this.track(this.Object3D, prediction)
                            } else if (calculateFun === "Heartglasses") {
                                //爱心眼镜【计算】
                                this.trackHeartglasses(this.Object3D, prediction)
                            }
                        }
                        this.renderer.render(this.scene, this.threeCamera)
                    },
                    resolveMesh(faceMesh, vw = this.canvasWidth, vh = this.canvasHeight) {
                        return faceMesh.map(p => [p[0] - vw / 2, vh / 2 - p[1], -p[2]])
                    },
                    //镜像切换
                    async triggerToggleFlipHorizontal() {
                        this.flipHorizontal = !this.flipHorizontal;
                        this.changeMesh(this.meshIndex);
                    },
                    actionSelect(value) {
                        const { deviceId } = value;
                        this.actionShow = false;
                        if (!isObjEmpty(deviceId) && this.deviceId != deviceId) {
                            this.deviceId = deviceId;
                            window.localStorage.setItem(`deviceId`, deviceId);
                            this.openCamera();
                        }
                    },
                    async getMediaDevices() {
                        let deviceList = await this.camera.getMediaDevices();
                        this.deviceList = deviceList.map(e => {
                            e.name = e.label || e.deviceId;
                            e.color = e.deviceId == this.deviceId ? '#1989fa' : '#323233';
                            return e
                        })
                    },
                    async cameraInit() {
                        const video = this.$refs.video;
                        if (this.width > 960) {
                            this.width = 960;
                            this.height = 540;
                        }
                        this.camera = new Camera(video, {
                            audio: false,
                            video: isPhone() ? { frameRate: 60 } : { width: this.width, height: this.height, frameRate: 60 }
                        });
                        await this.getMediaDevices();
                    },
                    openCamera() {
                        const toast = this.$toast.loading({
                            duration: 0, // 持续展示 toast
                            forbidClick: true,
                            message: '打开摄像头',
                        });
                        this.isCameraOpen = false;
                        this.camera.open(this.deviceId)
                            .then(async res => {
                                const video = this.$refs.video;
                                const { videoWidth, videoHeight } = video;
                                const { clientWidth, clientHeight } = video;
                                this.canvasWidth = videoWidth;
                                this.canvasHeight = videoHeight;
                                video.style.width = videoWidth + 'px';
                                video.style.height = videoHeight + 'px';
                                this.$refs.wrapper.style.width = clientWidth + 'px';
                                this.$refs.wrapper.style.height = (videoWidth / clientWidth) * clientHeight + 'px';
                                this.isCameraOpen = true;
                                if (res.settings && res.settings.deviceId) {
                                    this.deviceId = res.settings.deviceId;
                                    if (this.deviceList.filter(e => e.deviceId == this.deviceId).length === 0) {
                                        this.deviceList.unshift({
                                            color: `#1989fa`,
                                            name: res.label || '[未知设备]',
                                            deviceId: this.deviceId
                                        })
                                    }
                                    window.localStorage.setItem(`deviceId`, this.deviceId);
                                };
                                await this.createModel();
                                this.Create3dScene();
                                window.cancelAnimationFrame(this.task);
                                this.task = window.requestAnimationFrame(this.recognition);
                            })
                            .catch(error => {
                                console.log(error)
                                this.$dialog.alert({
                                    title: '失败',
                                    message: `打开摄像头失败：${error.errMsg}`,
                                    theme: 'round-button',
                                }).then(() => {
                                    location.reload();
                                });
                            })
                            .finally(() => {
                                toast.clear();
                            })
                    },
                    //创建模型
                    createModel() {
                        return new Promise(async resolve => {
                            this.modelLoad = true;
                            const toast = this.$toast.loading({
                                duration: 0, // 持续展示 toast
                                forbidClick: true,
                                message: '加载模型中',
                            });
                            await tf.setBackend('webgl')
                            const model = faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh;
                            const detectorConfig = {
                                maxFaces: 1, //检测到的最大面部数量
                                refineLandmarks: true, //可以完善眼睛和嘴唇周围的地标坐标，并在虹膜周围输出其他地标
                                runtime: 'mediapipe',
                                solutionPath: 'https://unpkg.com/@mediapipe/face_mesh', //WASM二进制文件和模型文件所在的路径
                            };
                            this.model = await faceLandmarksDetection.createDetector(model, detectorConfig);
                            toast.clear();
                            this.modelLoad = false;
                            resolve(this.model);
                        })
                    },
                    //识别
                    async recognition() {
                        try {
                            if (this.isCameraOpen && !this.modelLoad && !this.isPause) {
                                const video = this.$refs.video;
                                const faces = await this.model.estimateFaces(video, {
                                    flipHorizontal: false, //镜像
                                    // flipHorizontal: this.flipHorizontal, //镜像
                                });

                                if (this.tabsActive == "stickers") {
                                    if (faces.length > 0) {
                                        var keypoints = faces[0].keypoints;
                                        this.renderStickers({
                                            scaledMesh: keypoints.reduce((acc, pos) => {
                                                acc.push([pos.x, pos.y, pos.z])
                                                return acc
                                            }, [])
                                        });
                                    } else {
                                        this.renderStickers({ scaledMesh: [] })
                                    }
                                };
                                if (this.tabsActive == "3Dmodel") {
                                    if (faces.length > 0) {
                                        var keypoints = faces[0].keypoints;
                                        var scaledMesh = keypoints.reduce((acc, pos) => {
                                            acc.push([pos.x, pos.y, pos.z])
                                            return acc
                                        }, []);
                                        const faceMesh = this.resolveMesh(scaledMesh)

                                        // 计算眨眼，张嘴的幅度
                                        const faceRig = Kalidokit.Face.solve(keypoints, {
                                            runtime: "mediapipe",
                                            video,
                                            imageSize: { height: this.canvasHeight, width: this.canvasWidth },
                                            smoothBlink: false, // 平滑左右眼眨眼延迟
                                            blinkSettings: [0.25, 0.75], // 调整上下边界眨眼灵敏度
                                        });
                                        this.Object3D && (this.Object3D.visible = true)
                                        this.render3D({
                                            midwayBetweenEyes: [168].map(idx => faceMesh[idx]),
                                            scaledMesh,
                                            faceMesh,
                                            faceRig,
                                        });
                                    } else {
                                        this.Object3D && (this.Object3D.visible = false)
                                        this.renderer.render(this.scene, this.threeCamera)
                                    }
                                };
                            };
                            this.task = window.requestAnimationFrame(this.recognition);
                        } catch (error) {
                            console.log(error);
                            this.task = window.requestAnimationFrame(this.recognition);
                        }
                    }
                },
            })
        </script>
    </body>

</html>